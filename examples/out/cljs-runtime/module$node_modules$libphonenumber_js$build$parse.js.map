{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$parse.js",
"lineCount":159,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/parse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$parse\"] = function(global,require,module,exports) {\n\"use strict\";\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = parse;\nvar _constants = require(\"./constants.js\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError.js\"));\nvar _metadata = _interopRequireDefault(require(\"./metadata.js\"));\nvar _isViablePhoneNumber = _interopRequireWildcard(require(\"./helpers/isViablePhoneNumber.js\"));\nvar _extractExtension = _interopRequireDefault(require(\"./helpers/extension/extractExtension.js\"));\nvar _parseIncompletePhoneNumber = _interopRequireDefault(require(\"./parseIncompletePhoneNumber.js\"));\nvar _getCountryCallingCode = _interopRequireDefault(require(\"./getCountryCallingCode.js\"));\nvar _isPossible = require(\"./isPossible.js\");\nvar _PhoneNumber = _interopRequireDefault(require(\"./PhoneNumber.js\"));\nvar _matchesEntirely = _interopRequireDefault(require(\"./helpers/matchesEntirely.js\"));\nvar _extractCountryCallingCode = _interopRequireDefault(require(\"./helpers/extractCountryCallingCode.js\"));\nvar _extractNationalNumber = _interopRequireDefault(require(\"./helpers/extractNationalNumber.js\"));\nvar _stripIddPrefix = _interopRequireDefault(require(\"./helpers/stripIddPrefix.js\"));\nvar _getCountryByCallingCode = _interopRequireDefault(require(\"./helpers/getCountryByCallingCode.js\"));\nvar _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri = _interopRequireDefault(require(\"./helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, \"default\": e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\n// import { parseRFC3966 } from './helpers/RFC3966.js'\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nvar MAX_INPUT_STRING_LENGTH = 250;\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + _constants.PLUS_CHARS + _constants.VALID_DIGITS + ']');\n\n// Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + _constants.VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;\n\n// Examples:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\n/**\r\n * Parses a phone number.\r\n *\r\n * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)\r\n * parse('123456789', { defaultCountry: 'RU' }, metadata)\r\n * parse('123456789', undefined, metadata)\r\n *\r\n * @param  {string} input\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).\r\n */\nfunction parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new _metadata[\"default\"](metadata);\n\n  // Validate `defaultCountry`.\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('INVALID_COUNTRY');\n    }\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  }\n\n  // Parse the phone number.\n  var _parseInput = parseInput(text, options.v2, options.extract),\n    formattedPhoneNumber = _parseInput.number,\n    ext = _parseInput.ext,\n    error = _parseInput.error;\n\n  // If the phone number is not viable then return nothing.\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      if (error === 'TOO_SHORT') {\n        throw new _ParseError[\"default\"]('TOO_SHORT');\n      }\n      throw new _ParseError[\"default\"]('NOT_A_NUMBER');\n    }\n    return {};\n  }\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n    country = _parsePhoneNumber.country,\n    nationalNumber = _parsePhoneNumber.nationalNumber,\n    countryCallingCode = _parsePhoneNumber.countryCallingCode,\n    countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource,\n    carrierCode = _parsePhoneNumber.carrierCode;\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('INVALID_COUNTRY');\n    }\n    return {};\n  }\n\n  // Validate national (significant) number length.\n  if (!nationalNumber || nationalNumber.length < _constants.MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('TOO_SHORT');\n    }\n    // Google's demo just throws an error in this case.\n    return {};\n  }\n\n  // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n  if (nationalNumber.length > _constants.MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('TOO_LONG');\n    }\n    // Google's demo just throws an error in this case.\n    return {};\n  }\n  if (options.v2) {\n    var phoneNumber = new _PhoneNumber[\"default\"](countryCallingCode, nationalNumber, metadata.metadata);\n    if (country) {\n      phoneNumber.country = country;\n    }\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;\n    return phoneNumber;\n  }\n\n  // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? (0, _matchesEntirely[\"default\"])(nationalNumber, metadata.nationalNumberPattern()) : false;\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  }\n\n  // isInternational: countryCallingCode !== undefined\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && (0, _isPossible.isPossibleNumber)(nationalNumber, country, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] \u2014 If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] \u2014 By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\nfunction _extractFormattedPhoneNumber(text, extract, throwOnError) {\n  if (!text) {\n    return;\n  }\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new _ParseError[\"default\"]('TOO_LONG');\n    }\n    return;\n  }\n  if (extract === false) {\n    return text;\n  }\n  // Attempt to extract a possible number from the string passed in\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n  if (startsAt < 0) {\n    return;\n  }\n  return text\n  // Trim everything to the left of the phone number\n  .slice(startsAt)\n  // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\nfunction parseInput(text, v2, extract) {\n  // // Parse RFC 3966 phone number URI.\n  // if (text && text.indexOf('tel:') === 0) {\n  // \treturn parseRFC3966(text)\n  // }\n  // let number = extractFormattedPhoneNumber(text, extract, v2)\n  var number = (0, _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri[\"default\"])(text, {\n    extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text) {\n      return _extractFormattedPhoneNumber(text, extract, v2);\n    }\n  });\n  // If the phone number is not viable, then abort.\n  if (!number) {\n    return {};\n  }\n  if (!(0, _isViablePhoneNumber[\"default\"])(number)) {\n    if ((0, _isViablePhoneNumber.isViablePhoneNumberStart)(number)) {\n      return {\n        error: 'TOO_SHORT'\n      };\n    }\n    return {};\n  }\n  // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n  var withExtensionStripped = (0, _extractExtension[\"default\"])(number);\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n  return {\n    number: number\n  };\n}\n\n/**\r\n * Creates `parse()` result object.\r\n */\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n  if (ext) {\n    result.ext = ext;\n  }\n  return result;\n}\n\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber \u2014 Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = (0, _extractCountryCallingCode[\"default\"])((0, _parseIncompletePhoneNumber[\"default\"])(formattedPhoneNumber), undefined, defaultCountry, defaultCallingCode, metadata.metadata),\n    countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource,\n    countryCallingCode = _extractCountryCallin.countryCallingCode,\n    number = _extractCountryCallin.number;\n\n  // The exact country of the phone number\n  var country;\n\n  // If `formattedPhoneNumber` is passed in \"international\" format,\n  // choose a country by `countryCallingCode`.\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  }\n  // Else, if `formattedPhoneNumber` is passed in \"national\" format,\n  // then `number` is defined and `countryCallingCode` is `undefined`.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n    if (defaultCountry) {\n      country = defaultCountry;\n    } else {\n      /* istanbul ignore if */\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n          country = '001';\n        }\n      }\n    }\n    countryCallingCode = defaultCallingCode || (0, _getCountryCallingCode[\"default\"])(defaultCountry, metadata.metadata);\n  } else return {};\n  if (!number) {\n    return {\n      countryCallingCodeSource: countryCallingCodeSource,\n      countryCallingCode: countryCallingCode\n    };\n  }\n  var _extractNationalNumbe = (0, _extractNationalNumber[\"default\"])((0, _parseIncompletePhoneNumber[\"default\"])(number), country, metadata),\n    nationalNumber = _extractNationalNumbe.nationalNumber,\n    carrierCode = _extractNationalNumbe.carrierCode;\n\n  // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n  var exactCountry = (0, _getCountryByCallingCode[\"default\"])(countryCallingCode, {\n    nationalNumber: nationalNumber,\n    metadata: metadata\n  });\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n    if (exactCountry === '001') {\n      // Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.selectNumberingPlan(country);\n    }\n  }\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    countryCallingCodeSource: countryCallingCodeSource,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n//# sourceMappingURL=parse.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","o","Symbol","iterator","constructor","prototype","_interopRequireWildcard","e","t","WeakMap","r","n","__esModule","i","f","__proto__","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_interopRequireDefault","parseInput","text","v2","extract","number","_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri","extractFormattedPhoneNumber","length","MAX_INPUT_STRING_LENGTH","_ParseError","startsAt","search","PHONE_NUMBER_START_PATTERN","slice","replace","AFTER_PHONE_NUMBER_END_PATTERN","_isViablePhoneNumber","isViablePhoneNumberStart","error","withExtensionStripped","_extractExtension","ext","value","parse","options","metadata","_metadata","defaultCountry","hasCountry","Error","concat","_parseInput","formattedPhoneNumber","defaultCallingCode","_extractCountryCallin","_extractCountryCallingCode","_parseIncompletePhoneNumber","undefined","countryCallingCodeSource","countryCallingCode","selectNumberingPlan","country","USE_NON_GEOGRAPHIC_COUNTRY_CODE","isNonGeographicCallingCode","_getCountryCallingCode","_extractNationalNumbe","_extractNationalNumber","nationalNumber","carrierCode","exactCountry","_getCountryByCallingCode","hasSelectedNumberingPlan","_constants","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","phoneNumber","_PhoneNumber","__countryCallingCodeSource","valid","extended","_matchesEntirely","nationalNumberPattern","possible","possibleLengths","_isPossible","isPossibleNumber","phone","result","RegExp","PLUS_CHARS","VALID_DIGITS"]
}

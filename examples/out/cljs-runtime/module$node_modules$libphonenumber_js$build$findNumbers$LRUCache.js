shadow$provide.module$node_modules$libphonenumber_js$build$findNumbers$LRUCache = function(global, require, module, exports) {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
      return typeof o;
    } : function(o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _defineProperties(e$jscomp$0, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1;
      o.configurable = !0;
      "value" in o && (o.writable = !0);
      var JSCompiler_temp_const = Object, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.defineProperty;
      a: {
        var JSCompiler_inline_result = o.key;
        if ("object" == _typeof(JSCompiler_inline_result) && JSCompiler_inline_result) {
          var e = JSCompiler_inline_result[Symbol.toPrimitive];
          if (void 0 !== e) {
            JSCompiler_inline_result = e.call(JSCompiler_inline_result, "string");
            if ("object" != _typeof(JSCompiler_inline_result)) {
              break a;
            }
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          JSCompiler_inline_result = String(JSCompiler_inline_result);
        }
      }
      JSCompiler_inline_result = "symbol" == _typeof(JSCompiler_inline_result) ? JSCompiler_inline_result : JSCompiler_inline_result + "";
      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, e$jscomp$0, JSCompiler_inline_result, o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {writable:!1}), e;
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports["default"] = void 0;
  var Node = _createClass(function Node(key, value) {
    var next = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, prev = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    _classCallCheck(this, Node);
    this.key = key;
    this.value = value;
    this.next = next;
    this.prev = prev;
  });
  exports["default"] = function() {
    function LRUCache() {
      var limit = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
      _classCallCheck(this, LRUCache);
      this.size = 0;
      this.limit = limit;
      this.tail = this.head = null;
      this.cache = {};
    }
    return _createClass(LRUCache, [{key:"put", value:function(key, value) {
      this.ensureLimit();
      this.head ? (value = new Node(key, value, this.head), this.head = this.head.prev = value) : this.head = this.tail = new Node(key, value);
      this.cache[key] = this.head;
      this.size++;
    }}, {key:"get", value:function(key) {
      if (this.cache[key]) {
        var value = this.cache[key].value;
        this.remove(key);
        this.put(key, value);
        return value;
      }
      console.log("Item not available in cache for key ".concat(key));
    }}, {key:"ensureLimit", value:function() {
      this.size === this.limit && this.remove(this.tail.key);
    }}, {key:"remove", value:function(key) {
      var node = this.cache[key];
      null !== node.prev ? node.prev.next = node.next : this.head = node.next;
      null !== node.next ? node.next.prev = node.prev : this.tail = node.prev;
      delete this.cache[key];
      this.size--;
    }}, {key:"clear", value:function() {
      this.tail = this.head = null;
      this.size = 0;
      this.cache = {};
    }}]);
  }();
};

//# sourceMappingURL=module$node_modules$libphonenumber_js$build$findNumbers$LRUCache.js.map

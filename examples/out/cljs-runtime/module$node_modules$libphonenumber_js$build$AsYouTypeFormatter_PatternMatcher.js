shadow$provide.module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternMatcher = function(global, require, module, exports) {
  function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) {
      return (t = t.call(r)).next.bind(t);
    }
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var o = 0;
      return function() {
        return o >= r.length ? {done:!0} : {done:!1, value:r[o++]};
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) {
        return _arrayLikeToArray(r, a);
      }
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) {
      n[e] = r[e];
    }
    return n;
  }
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
      return typeof o;
    } : function(o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _defineProperties(e$jscomp$0, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1;
      o.configurable = !0;
      "value" in o && (o.writable = !0);
      var JSCompiler_temp_const = Object, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.defineProperty;
      a: {
        var JSCompiler_inline_result = o.key;
        if ("object" == _typeof(JSCompiler_inline_result) && JSCompiler_inline_result) {
          var e = JSCompiler_inline_result[Symbol.toPrimitive];
          if (void 0 !== e) {
            JSCompiler_inline_result = e.call(JSCompiler_inline_result, "string");
            if ("object" != _typeof(JSCompiler_inline_result)) {
              break a;
            }
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          JSCompiler_inline_result = String(JSCompiler_inline_result);
        }
      }
      JSCompiler_inline_result = "symbol" == _typeof(JSCompiler_inline_result) ? JSCompiler_inline_result : JSCompiler_inline_result + "";
      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, e$jscomp$0, JSCompiler_inline_result, o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {writable:!1}), e;
  }
  function _match(characters, tree, last) {
    if ("string" === typeof tree) {
      var characterString = characters.join("");
      if (0 === tree.indexOf(characterString)) {
        return characters.length === tree.length ? {match:!0, matchedChars:characters} : {partialMatch:!0};
      }
      if (0 === characterString.indexOf(tree)) {
        return last && characters.length > tree.length ? {overflow:!0} : {match:!0, matchedChars:characters.slice(0, tree.length)};
      }
    } else {
      if (Array.isArray(tree)) {
        characterString = characters.slice();
        for (var i = 0; i < tree.length;) {
          var result = _match(characterString, tree[i], last && i === tree.length - 1);
          if (result) {
            if (result.overflow) {
              return result;
            }
            if (result.match) {
              if (characterString = characterString.slice(result.matchedChars.length), 0 === characterString.length) {
                return i === tree.length - 1 ? {match:!0, matchedChars:characters} : {partialMatch:!0};
              }
            } else {
              if (result.partialMatch) {
                return {partialMatch:!0};
              }
              throw Error("Unsupported match result:\n".concat(JSON.stringify(result, null, 2)));
            }
          } else {
            return;
          }
          i++;
        }
        return last ? {overflow:!0} : {match:!0, matchedChars:characters.slice(0, characters.length - characterString.length)};
      }
      switch(tree.op) {
        case "|":
          for (tree = _createForOfIteratorHelperLoose(tree.args); !(i = tree()).done;) {
            if (i = _match(characters, i.value, last)) {
              if (i.overflow) {
                return i;
              }
              if (i.match) {
                return {match:!0, matchedChars:i.matchedChars};
              }
              if (i.partialMatch) {
                characterString = !0;
              } else {
                throw Error("Unsupported match result:\n".concat(JSON.stringify(i, null, 2)));
              }
            }
          }
          if (characterString) {
            return {partialMatch:!0};
          }
          break;
        case "[]":
          for (tree = _createForOfIteratorHelperLoose(tree.args); !(characterString = tree()).done;) {
            if (characterString = characterString.value, characters[0] === characterString) {
              return 1 === characters.length ? {match:!0, matchedChars:characters} : last ? {overflow:!0} : {match:!0, matchedChars:[characterString]};
            }
          }
          break;
        default:
          throw Error("Unsupported instruction tree: ".concat(tree));
      }
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports["default"] = void 0;
  var _AsYouTypeFormatterPatternParser = function(e) {
    return e && e.__esModule ? e : {"default":e};
  }(require("module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternParser"));
  exports["default"] = function() {
    function PatternMatcher(pattern) {
      if (!(this instanceof PatternMatcher)) {
        throw new TypeError("Cannot call a class as a function");
      }
      this.matchTree = (new _AsYouTypeFormatterPatternParser["default"]()).parse(pattern);
    }
    return _createClass(PatternMatcher, [{key:"match", value:function(string) {
      var allowOverflow = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).allowOverflow;
      if (!string) {
        throw Error("String is required");
      }
      var result = _match(string.split(""), this.matchTree, !0);
      result && result.match && delete result.matchedChars;
      if (!result || !result.overflow || allowOverflow) {
        return result;
      }
    }}]);
  }();
};

//# sourceMappingURL=module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternMatcher.js.map

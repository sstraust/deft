{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$AsYouTypeParser.js",
"lineCount":217,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/AsYouTypeParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$AsYouTypeParser\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nexports.extractFormattedDigitsAndPlus = extractFormattedDigitsAndPlus;\nvar _extractCountryCallingCode2 = _interopRequireDefault(require(\"./helpers/extractCountryCallingCode.js\"));\nvar _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = _interopRequireDefault(require(\"./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js\"));\nvar _extractNationalNumberFromPossiblyIncompleteNumber = _interopRequireDefault(require(\"./helpers/extractNationalNumberFromPossiblyIncompleteNumber.js\"));\nvar _stripIddPrefix = _interopRequireDefault(require(\"./helpers/stripIddPrefix.js\"));\nvar _parseDigits = _interopRequireDefault(require(\"./helpers/parseDigits.js\"));\nvar _constants = require(\"./constants.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');\nvar VALID_FORMATTED_PHONE_NUMBER_PART = '(?:' + '[' + _constants.PLUS_CHARS + ']' + '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']*' + '|' + '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+' + ')';\nvar AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+' + '.*' + '$');\n\n// Tests whether `national_prefix_for_parsing` could match\n// different national prefixes.\n// Matches anything that's not a digit or a square bracket.\nvar COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/;\nvar AsYouTypeParser = exports[\"default\"] = /*#__PURE__*/function () {\n  function AsYouTypeParser(_ref) {\n    var defaultCountry = _ref.defaultCountry,\n      defaultCallingCode = _ref.defaultCallingCode,\n      metadata = _ref.metadata,\n      onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;\n    _classCallCheck(this, AsYouTypeParser);\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.metadata = metadata;\n    this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;\n  }\n  return _createClass(AsYouTypeParser, [{\n    key: \"input\",\n    value: function input(text, state) {\n      var _extractFormattedDigi = extractFormattedDigitsAndPlus(text),\n        _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2),\n        formattedDigits = _extractFormattedDigi2[0],\n        hasPlus = _extractFormattedDigi2[1];\n      var digits = (0, _parseDigits[\"default\"])(formattedDigits);\n      // Checks for a special case: just a leading `+` has been entered.\n      var justLeadingPlus;\n      if (hasPlus) {\n        if (!state.digits) {\n          state.startInternationalNumber(undefined, undefined);\n          if (!digits) {\n            justLeadingPlus = true;\n          }\n        }\n      }\n      if (digits) {\n        this.inputDigits(digits, state);\n      }\n      return {\n        digits: digits,\n        justLeadingPlus: justLeadingPlus\n      };\n    }\n\n    /**\r\n     * Inputs \"next\" phone number digits.\r\n     * @param  {string} digits\r\n     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n     */\n  }, {\n    key: \"inputDigits\",\n    value: function inputDigits(nextDigits, state) {\n      var digits = state.digits;\n      var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;\n\n      // Append phone number digits.\n      state.appendDigits(nextDigits);\n\n      // Attempt to extract IDD prefix:\n      // Some users input their phone number in international format,\n      // but in an \"out-of-country\" dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers as soon as there're at least 3 digits.\n      // Google's library attempts to extract IDD prefix at 3 digits,\n      // so this library just copies that behavior.\n      // I guess that's because the most commot IDD prefixes are\n      // `00` (Europe) and `011` (US).\n      // There exist really long IDD prefixes too:\n      // for example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      // An IDD prefix is extracted here, and then every time when\n      // there's a new digit and the number couldn't be formatted.\n      if (hasReceivedThreeLeadingDigits) {\n        this.extractIddPrefix(state);\n      }\n      if (this.isWaitingForCountryCallingCode(state)) {\n        if (!this.extractCountryCallingCode(state)) {\n          return;\n        }\n      } else {\n        state.appendNationalSignificantNumberDigits(nextDigits);\n      }\n\n      // If a phone number is being input in international format,\n      // then it's not valid for it to have a national prefix.\n      // Still, some people incorrectly input such numbers with a national prefix.\n      // In such cases, only attempt to strip a national prefix if the number becomes too long.\n      // (but that is done later, not here)\n      if (!state.international) {\n        if (!this.hasExtractedNationalSignificantNumber) {\n          this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n            return state.update(stateUpdate);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"isWaitingForCountryCallingCode\",\n    value: function isWaitingForCountryCallingCode(_ref2) {\n      var international = _ref2.international,\n        callingCode = _ref2.callingCode;\n      return international && !callingCode;\n    }\n\n    // Extracts a country calling code from a number\n    // being entered in internatonal format.\n  }, {\n    key: \"extractCountryCallingCode\",\n    value: function extractCountryCallingCode(state) {\n      var _extractCountryCallin = (0, _extractCountryCallingCode2[\"default\"])('+' + state.getDigitsWithoutInternationalPrefix(), state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n        countryCallingCode = _extractCountryCallin.countryCallingCode,\n        number = _extractCountryCallin.number;\n      if (countryCallingCode) {\n        state.setCallingCode(countryCallingCode);\n        state.update({\n          nationalSignificantNumber: number\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan) {\n      if (numberingPlan) {\n        this.hasSelectedNumberingPlan = true;\n        var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);\n      } else {\n        this.hasSelectedNumberingPlan = undefined;\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;\n      }\n    }\n\n    /**\r\n     * Extracts a national (significant) number from user input.\r\n     * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n     * and doesn't apply `national_prefix_transform_rule` after that.\r\n     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n     * @return {boolean} [extracted]\r\n     */\n  }, {\n    key: \"extractNationalSignificantNumber\",\n    value: function extractNationalSignificantNumber(nationalDigits, setState) {\n      if (!this.hasSelectedNumberingPlan) {\n        return;\n      }\n      var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumber[\"default\"])(nationalDigits, this.metadata),\n        nationalPrefix = _extractNationalNumbe.nationalPrefix,\n        nationalNumber = _extractNationalNumbe.nationalNumber,\n        carrierCode = _extractNationalNumbe.carrierCode;\n      if (nationalNumber === nationalDigits) {\n        return;\n      }\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n\n    /**\r\n     * In Google's code this function is called \"attempt to extract longer NDD\".\r\n     * \"Some national prefixes are a substring of others\", they say.\r\n     * @return {boolean} [result] \u2014 Returns `true` if extracting a national prefix produced different results from what they were.\r\n     */\n  }, {\n    key: \"extractAnotherNationalSignificantNumber\",\n    value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\n      if (!this.hasExtractedNationalSignificantNumber) {\n        return this.extractNationalSignificantNumber(nationalDigits, setState);\n      }\n      if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\n        return;\n      }\n      var _extractNationalNumbe2 = (0, _extractNationalNumberFromPossiblyIncompleteNumber[\"default\"])(nationalDigits, this.metadata),\n        nationalPrefix = _extractNationalNumbe2.nationalPrefix,\n        nationalNumber = _extractNationalNumbe2.nationalNumber,\n        carrierCode = _extractNationalNumbe2.carrierCode;\n      // If a national prefix has been extracted previously,\n      // then it's always extracted as additional digits are added.\n      // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\n      // doesn't do anything different from what it currently does.\n      // So, just in case, here's this check, though it doesn't occur.\n      /* istanbul ignore if */\n      if (nationalNumber === prevNationalSignificantNumber) {\n        return;\n      }\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n  }, {\n    key: \"onExtractedNationalNumber\",\n    value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {\n      // Tells if the parsed national (significant) number is present as-is in the input string.\n      // For example, when inputting \"0343515551212999\" Argentinian mobile number,\n      // the parsed national (significant) number is \"93435551212999\".\n      // There, one can see how it stripped \"0\" national prefix and prepended a \"9\",\n      // because that's how it is instructed to do in Argentina's metadata.\n      // So in the described example, the parsed national (significant) number is not present\n      // as-is in the input string. Instead, it's \"modified\" in the input string.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      var nationalSignificantNumberIsModified = false;\n\n      // In some countries, a phone number could have a prefix that is not a \"national prefix\"\n      // but rather some other type of \"utility\" prefix.\n      // For example, when calling within Australia, one could prepend `1831` prefix to hide\n      // caller's phone number.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      var prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\n\n      // `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.\n      var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);\n\n      // If the parsed national (significant) number is the last substring of the `nationalDigits`,\n      // then it means that it's present as-is in the input string.\n      // In any other case, the parsed national (significant) number is \"modified\" in the input string.\n      if (nationalSignificantNumberIndex < 0 || nationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length) {\n        nationalSignificantNumberIsModified = true;\n      } else {\n        var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);\n        // When national (significant) number is equal to the `nationalDigits`,\n        // this `onExtractedNationalNumber()` function simply doesn't get called.\n        // This means that at this point, `prefixBeforeNationalNumber` is always non-empty.\n        // Still, added this `if` check just to prevent potential silly bugs.\n        // The `!prefixBeforeNationalNumber` case is not really testable\n        // so this line is exluded from the code coverage.\n        /* istanbul ignore if */\n        if (prefixBeforeNationalNumber) {\n          if (prefixBeforeNationalNumber !== nationalPrefix) {\n            prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber;\n          }\n        }\n      }\n      setState({\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode,\n        nationalSignificantNumber: nationalSignificantNumber,\n        nationalSignificantNumberIsModified: nationalSignificantNumberIsModified,\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix: prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\n      });\n      // `onExtractedNationalNumber()` is only called when\n      // the national (significant) number actually did change.\n      this.hasExtractedNationalSignificantNumber = true;\n      this.onNationalSignificantNumberChange();\n    }\n  }, {\n    key: \"reExtractNationalSignificantNumber\",\n    value: function reExtractNationalSignificantNumber(state) {\n      // Attempt to extract a national prefix.\n      //\n      // Some people incorrectly input national prefix\n      // in an international phone number.\n      // For example, some people write British phone numbers as `+44(0)...`.\n      //\n      // Also, in some rare cases, it is valid for a national prefix\n      // to be a part of an international phone number.\n      // For example, mobile phone numbers in Mexico are supposed to be\n      // dialled internationally using a `1` national prefix,\n      // so the national prefix will be part of an international number.\n      //\n      // Quote from:\n      // https://www.mexperience.com/dialing-cell-phones-in-mexico/\n      //\n      // \"Dialing a Mexican cell phone from abroad\n      // When you are calling a cell phone number in Mexico from outside Mexico,\n      // it\u2019s necessary to dial an additional \u201c1\u201d after Mexico\u2019s country code\n      // (which is \u201c52\u201d) and before the area code.\n      // You also ignore the 045, and simply dial the area code and the\n      // cell phone\u2019s number.\n      //\n      // If you don\u2019t add the \u201c1\u201d, you\u2019ll receive a recorded announcement\n      // asking you to redial using it.\n      //\n      // For example, if you are calling from the USA to a cell phone\n      // in Mexico City, you would dial +52 \u2013 1 \u2013 55 \u2013 1234 5678.\n      // (Note that this is different to calling a land line in Mexico City\n      // from abroad, where the number dialed would be +52 \u2013 55 \u2013 1234 5678)\".\n      //\n      // Google's demo output:\n      // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\n      //\n      if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function (stateUpdate) {\n        return state.update(stateUpdate);\n      })) {\n        return true;\n      }\n      // If no format matches the phone number, then it could be\n      // \"a really long IDD\" (quote from a comment in Google's library).\n      // An IDD prefix is first extracted when the user has entered at least 3 digits,\n      // and then here \u2014 every time when there's a new digit and the number\n      // couldn't be formatted.\n      // For example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      //\n      // Could also check `!hasReceivedThreeLeadingDigits` here\n      // to filter out the case when this check duplicates the one\n      // already performed when there're 3 leading digits,\n      // but it's not a big deal, and in most cases there\n      // will be a suitable `format` when there're 3 leading digits.\n      //\n      if (this.extractIddPrefix(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n      // Google's AsYouType formatter supports sort of an \"autocorrection\" feature\n      // when it \"autocorrects\" numbers that have been input for a country\n      // with that country's calling code.\n      // Such \"autocorrection\" feature looks weird, but different people have been requesting it:\n      // https://github.com/catamphetamine/libphonenumber-js/issues/376\n      // https://github.com/catamphetamine/libphonenumber-js/issues/375\n      // https://github.com/catamphetamine/libphonenumber-js/issues/316\n      if (this.fixMissingPlus(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n    }\n  }, {\n    key: \"extractIddPrefix\",\n    value: function extractIddPrefix(state) {\n      // An IDD prefix can't be present in a number written with a `+`.\n      // Also, don't re-extract an IDD prefix if has already been extracted.\n      var international = state.international,\n        IDDPrefix = state.IDDPrefix,\n        digits = state.digits,\n        nationalSignificantNumber = state.nationalSignificantNumber;\n      if (international || IDDPrefix) {\n        return;\n      }\n      // Some users input their phone number in \"out-of-country\"\n      // dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers.\n      var numberWithoutIDD = (0, _stripIddPrefix[\"default\"])(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);\n      if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\n        // If an IDD prefix was stripped then convert the IDD-prefixed number\n        // to international number for subsequent parsing.\n        state.update({\n          IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\n        });\n        this.startInternationalNumber(state, {\n          country: undefined,\n          callingCode: undefined\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"fixMissingPlus\",\n    value: function fixMissingPlus(state) {\n      if (!state.international) {\n        var _extractCountryCallin2 = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign[\"default\"])(state.digits, state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n          newCallingCode = _extractCountryCallin2.countryCallingCode;\n        if (newCallingCode) {\n          state.update({\n            missingPlus: true\n          });\n          this.startInternationalNumber(state, {\n            country: state.country,\n            callingCode: newCallingCode\n          });\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(state, _ref3) {\n      var country = _ref3.country,\n        callingCode = _ref3.callingCode;\n      state.startInternationalNumber(country, callingCode);\n      // If a national (significant) number has been extracted before, reset it.\n      if (state.nationalSignificantNumber) {\n        state.resetNationalSignificantNumber();\n        this.onNationalSignificantNumberChange();\n        this.hasExtractedNationalSignificantNumber = undefined;\n      }\n    }\n  }, {\n    key: \"extractCallingCodeAndNationalSignificantNumber\",\n    value: function extractCallingCodeAndNationalSignificantNumber(state) {\n      if (this.extractCountryCallingCode(state)) {\n        // `this.extractCallingCode()` is currently called when the number\n        // couldn't be formatted during the standard procedure.\n        // Normally, the national prefix would be re-extracted\n        // for an international number if such number couldn't be formatted,\n        // but since it's already not able to be formatted,\n        // there won't be yet another retry, so also extract national prefix here.\n        this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n          return state.update(stateUpdate);\n        });\n      }\n    }\n  }]);\n}();\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\nfunction extractFormattedPhoneNumber(text) {\n  // Attempt to extract a possible number from the string passed in.\n  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);\n  if (startsAt < 0) {\n    return;\n  }\n  // Trim everything to the left of the phone number.\n  text = text.slice(startsAt);\n  // Trim the `+`.\n  var hasPlus;\n  if (text[0] === '+') {\n    hasPlus = true;\n    text = text.slice('+'.length);\n  }\n  // Trim everything to the right of the phone number.\n  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '');\n  // Re-add the previously trimmed `+`.\n  if (hasPlus) {\n    text = '+' + text;\n  }\n  return text;\n}\n\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\nfunction _extractFormattedDigitsAndPlus(text) {\n  // Extract a formatted phone number part from text.\n  var extractedNumber = extractFormattedPhoneNumber(text) || '';\n  // Trim a `+`.\n  if (extractedNumber[0] === '+') {\n    return [extractedNumber.slice('+'.length), true];\n  }\n  return [extractedNumber];\n}\n\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\nfunction extractFormattedDigitsAndPlus(text) {\n  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text),\n    _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2),\n    formattedDigits = _extractFormattedDigi4[0],\n    hasPlus = _extractFormattedDigi4[1];\n  // If the extracted phone number part\n  // can possibly be a part of some valid phone number\n  // then parse phone number characters from a formatted phone number.\n  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\n    formattedDigits = '';\n  }\n  return [formattedDigits, hasPlus];\n}\n//# sourceMappingURL=AsYouTypeParser.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","e","__esModule","_typeof","o","Symbol","iterator","constructor","prototype","_slicedToArray","r","Array","isArray","t","i","u","a","f","next","call","l","Object","done","push","value","length","n","_arrayLikeToArray","toString","slice","name","from","test","TypeError","_defineProperties","enumerable","configurable","writable","defineProperty","key","toPrimitive","String","_createClass","extractFormattedDigitsAndPlus","text","startsAt","search","VALID_FORMATTED_PHONE_NUMBER_PART","hasPlus","replace","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","extractedNumber","_extractFormattedDigi4","_extractFormattedDigi3","formattedDigits","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","_extractCountryCallingCode2","_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","_extractNationalNumberFromPossiblyIncompleteNumber","_stripIddPrefix","_parseDigits","_constants","RegExp","VALID_PUNCTUATION","VALID_DIGITS","PLUS_CHARS","COMPLEX_NATIONAL_PREFIX","AsYouTypeParser","_ref","defaultCountry","defaultCallingCode","metadata","onNationalSignificantNumberChange","input","state","_extractFormattedDigi","_extractFormattedDigi2","digits","justLeadingPlus","startInternationalNumber","undefined","inputDigits","nextDigits","hasReceivedThreeLeadingDigits","appendDigits","extractIddPrefix","isWaitingForCountryCallingCode","extractCountryCallingCode","appendNationalSignificantNumberDigits","international","hasExtractedNationalSignificantNumber","extractNationalSignificantNumber","getNationalDigits","stateUpdate","update","_ref2","callingCode","_extractCountryCallin","getDigitsWithoutInternationalPrefix","country","countryCallingCode","number","setCallingCode","nationalSignificantNumber","reset","numberingPlan","hasSelectedNumberingPlan","couldPossiblyExtractAnotherNationalSignificantNumber","nationalPrefixForParsing","_nationalPrefixForParsing","nationalDigits","setState","_extractNationalNumbe","nationalNumber","onExtractedNationalNumber","nationalPrefix","carrierCode","extractAnotherNationalSignificantNumber","prevNationalSignificantNumber","_extractNationalNumbe2","nationalSignificantNumberIsModified","prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix","nationalSignificantNumberIndex","lastIndexOf","prefixBeforeNationalNumber","reExtractNationalSignificantNumber","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","IDDPrefix","numberWithoutIDD","newCallingCode","_extractCountryCallin2","missingPlus","_ref3","resetNationalSignificantNumber"]
}

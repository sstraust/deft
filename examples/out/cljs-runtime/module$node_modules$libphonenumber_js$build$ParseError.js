shadow$provide.module$node_modules$libphonenumber_js$build$ParseError = function(global, require, module, exports) {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
      return typeof o;
    } : function(o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _defineProperties(e$jscomp$0, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1;
      o.configurable = !0;
      "value" in o && (o.writable = !0);
      var JSCompiler_temp_const = Object, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.defineProperty;
      a: {
        var JSCompiler_inline_result = o.key;
        if ("object" == _typeof(JSCompiler_inline_result) && JSCompiler_inline_result) {
          var e = JSCompiler_inline_result[Symbol.toPrimitive];
          if (void 0 !== e) {
            JSCompiler_inline_result = e.call(JSCompiler_inline_result, "string");
            if ("object" != _typeof(JSCompiler_inline_result)) {
              break a;
            }
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          JSCompiler_inline_result = String(JSCompiler_inline_result);
        }
      }
      JSCompiler_inline_result = "symbol" == _typeof(JSCompiler_inline_result) ? JSCompiler_inline_result : JSCompiler_inline_result + "";
      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, e$jscomp$0, JSCompiler_inline_result, o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {writable:!1}), e;
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) {
      throw new TypeError("Super expression must either be null or a function");
    }
    t.prototype = Object.create(e && e.prototype, {constructor:{value:t, writable:!0, configurable:!0}});
    Object.defineProperty(t, "prototype", {writable:!1});
    e && _setPrototypeOf(t, e);
  }
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function(t) {
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      if (null === t || !_isNativeFunction(t)) {
        return t;
      }
      if ("function" != typeof t) {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (void 0 !== r) {
        if (r.has(t)) {
          return r.get(t);
        }
        r.set(t, Wrapper);
      }
      return Wrapper.prototype = Object.create(t.prototype, {constructor:{value:Wrapper, enumerable:!1, writable:!0, configurable:!0}}), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) {
      return Reflect.construct.apply(null, arguments);
    }
    var o = [null];
    o.push.apply(o, e);
    o = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(o, r.prototype), o;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t) {
    }
    return (_isNativeReflectConstruct = function() {
      return !!t;
    })();
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports["default"] = void 0;
  exports["default"] = function(_Error) {
    function ParseError(code) {
      if (!(this instanceof ParseError)) {
        throw new TypeError("Cannot call a class as a function");
      }
      var _this = ParseError;
      code = [code];
      _this = _getPrototypeOf(_this);
      _this = _isNativeReflectConstruct() ? Reflect.construct(_this, code || [], _getPrototypeOf(this).constructor) : _this.apply(this, code);
      if (!_this || "object" != _typeof(_this) && "function" != typeof _this) {
        if (void 0 !== _this) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        if (void 0 === this) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        _this = this;
      }
      Object.setPrototypeOf(_this, ParseError.prototype);
      _this.name = _this.constructor.name;
      return _this;
    }
    _inherits(ParseError, _Error);
    return _createClass(ParseError);
  }(_wrapNativeSuper(Error));
};

//# sourceMappingURL=module$node_modules$libphonenumber_js$build$ParseError.js.map

{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$helpers$extractNationalNumber.js",
"lineCount":35,
"mappings":"AAAAA,cAAA,CAAA,yEAAA,GAA8F,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAWtIC,UAASA,uBAAsB,CAACC,CAAD,CAAI;AAAE,WAAOA,CAAA,IAAKA,CAAEC,CAAAA,UAAP,GAAoBD,CAApB,GAAwB,CAAE,UAAWA,CAAb,CAA/B;AAAF;AARnCE,QAAOC,CAAAA,cAAP,CAAsBL,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CM,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAN,SAAA,CAAQ,SAAR,CAAA,GAgBAO,QAA8B,CAACC,MAAD,EAASC,OAAT,EAAkBC,QAAlB,CAA4B;AAAA,QAUpDC,wBAAwB,GAAIC,kDAAA,CAAmD,SAAnD,CAAJ,EAAmEJ,MAAnE,EAA2EE,QAA3E,CAV4B,EAWtDG,cAAcF,qBAAsBE,CAAAA,WAXkB;AAYtDC,yBAAAA,GAAiBH,qBAAsBG,CAAAA,cAAvCA;AACF,QAAIA,qBAAJ,KAAuBN,MAAvB,CAA+B;AA0D7B,UAAA,2BADE,GAAIO,gBAAA,CAAiB,SAAjB,CAAJ,EAxDqCP,MAwDrC,EAxD6DE,QAwDGM,CAAAA,qBAAT,EAAvD,CAAJ,IAAgG,CAAC,GAAID,gBAAA,CAAiB,SAAjB,CAAJ,EAxDhDD,qBAwDgD,EAxDhCJ,QAwD+FM,CAAAA,qBAAT,EAAtD,CAAjG,GACS,CAAA,CADT,GAgBO,CAAA,CAfL;AAzDA,UAAI,CAAC,wBAAL;AAEE,eAAO,CACLF,eAAgBN,MADX,CAAP;AAFF;AAQA,UAAIE,QAASO,CAAAA,aAAcC,CAAAA,eAAvB,EAAJ,CAA8C;AAEvCT,eAAL,KACEA,OADF,GACY,GAAIU,wBAAA,CAAyB,SAAzB,CAAJ,EAAyCT,QAASO,CAAAA,aAAcG,CAAAA,WAAvB,EAAzC,EAA+E,CACvFN,eAAgBA,qBADuE,EAE7EJ,QAF6E,CAA/E,CADZ;AAgEyE,SAAA;AAC7E,iBAAQ,GAAIW,kBAAA,CAAmB,SAAnB,CAAJ,EAlDoCP,qBAkDpC,EAlDoDL,OAkDpD,EAlD6DC,QAkD7D,CAAR;AACE,iBAAK,WAAL;AACA,iBAAK,gBAAL;AAIE,qBAAA,GAAO,CAAA,CAAP;AAAA,oBAAA,CAAA;AACF;AACE,qBAAA,GAAO,CAAA,CAAP;AARJ;AAD6E;AAjDzE,YAAI,CAAC,OAAL;AAEE,iBAAO,CACLI,eAAgBN,MADX,CAAP;AAFF;AAjB4C;AATjB;AAkC/B,WAAO,CACLM,eAAgBA,qBADX,EAEQD,WAFR,CAAP;AA/CwD,GAhB1D;AACA,MAAID,qDAAqDX,sBAAA,CAAuBH,OAAA,CAAQ,uGAAR,CAAvB,CAAzD,EACIiB,mBAAmBd,sBAAA,CAAuBH,OAAA,CAAQ,qEAAR,CAAvB,CADvB,EAEIuB,qBAAqBpB,sBAAA,CAAuBH,OAAA,CAAQ,uEAAR,CAAvB,CAFzB,EAGIqB,2BAA2BlB,sBAAA,CAAuBH,OAAA,CAAQ,6EAAR,CAAvB,CAH/B;AAPsI,CAAtI;;",
"sources":["node_modules/libphonenumber-js/build/helpers/extractNationalNumber.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$helpers$extractNationalNumber\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = extractNationalNumber;\nvar _extractNationalNumberFromPossiblyIncompleteNumber = _interopRequireDefault(require(\"./extractNationalNumberFromPossiblyIncompleteNumber.js\"));\nvar _matchesEntirely = _interopRequireDefault(require(\"./matchesEntirely.js\"));\nvar _checkNumberLength = _interopRequireDefault(require(\"./checkNumberLength.js\"));\nvar _getCountryByCallingCode = _interopRequireDefault(require(\"./getCountryByCallingCode.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number \u2014 Complete phone number digits.\r\n * @param  {string?} country \u2014 Country, if known.\r\n * @param  {Metadata} metadata \u2014 Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\nfunction extractNationalNumber(number, country, metadata) {\n  // Parsing national prefixes and carrier codes\n  // is only required for local phone numbers\n  // but some people don't understand that\n  // and sometimes write international phone numbers\n  // with national prefixes (or maybe even carrier codes).\n  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\n  // Google's original library forgives such mistakes\n  // and so does this library, because it has been requested:\n  // https://github.com/catamphetamine/libphonenumber-js/issues/127\n  var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumber[\"default\"])(number, metadata),\n    carrierCode = _extractNationalNumbe.carrierCode,\n    nationalNumber = _extractNationalNumbe.nationalNumber;\n  if (nationalNumber !== number) {\n    if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {\n      // Don't strip the national prefix.\n      return {\n        nationalNumber: number\n      };\n    }\n    // Check the national (significant) number length after extracting national prefix and carrier code.\n    // Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature.\n    if (metadata.numberingPlan.possibleLengths()) {\n      // If an exact `country` is not specified, attempt to detect it from the assumed national number.\n      if (!country) {\n        country = (0, _getCountryByCallingCode[\"default\"])(metadata.numberingPlan.callingCode(), {\n          nationalNumber: nationalNumber,\n          metadata: metadata\n        });\n      }\n\n      // The number remaining after stripping the national prefix and carrier code\n      // should be long enough to have a possible length for the country.\n      // Otherwise, don't strip the national prefix and carrier code,\n      // since the original number could be a valid number.\n      // This check has been copy-pasted \"as is\" from Google's original library:\n      // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\n      // It doesn't check for the \"possibility\" of the original `number`.\n      // I guess it's fine not checking that one. It works as is anyway.\n      if (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {\n        // Don't strip the national prefix.\n        return {\n          nationalNumber: number\n        };\n      }\n    }\n  }\n  return {\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n\n// In some countries, the same digit could be a national prefix\n// or a leading digit of a valid phone number.\n// For example, in Russia, national prefix is `8`,\n// and also `800 555 35 35` is a valid number\n// in which `8` is not a national prefix, but the first digit\n// of a national (significant) number.\n// Same's with Belarus:\n// `82004910060` is a valid national (significant) number,\n// but `2004910060` is not.\n// To support such cases (to prevent the code from always stripping\n// national prefix), a condition is imposed: a national prefix\n// is not extracted when the original number is \"viable\" and the\n// resultant number is not, a \"viable\" national number being the one\n// that matches `national_number_pattern`.\nfunction shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {\n  // The equivalent in Google's code is:\n  // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\n  if ((0, _matchesEntirely[\"default\"])(nationalNumberBefore, metadata.nationalNumberPattern()) && !(0, _matchesEntirely[\"default\"])(nationalNumberAfter, metadata.nationalNumberPattern())) {\n    return false;\n  }\n  // This \"is possible\" national number (length) check has been commented out\n  // because it's superceded by the (effectively) same check done in the\n  // `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.\n  // In other words, why run the same check twice if it could only be run once.\n  // // Check the national (significant) number length after extracting national prefix and carrier code.\n  // // Fixes a minor \"weird behavior\" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57\n  // // (Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature).\n  // if (metadata.possibleLengths()) {\n  // \tif (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&\n  // \t\t!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {\n  // \t\treturn false\n  // \t}\n  // }\n  return true;\n}\nfunction isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {\n  switch ((0, _checkNumberLength[\"default\"])(nationalNumber, country, metadata)) {\n    case 'TOO_SHORT':\n    case 'INVALID_LENGTH':\n      // This library ignores \"local-only\" phone numbers (for simplicity).\n      // See the readme for more info on what are \"local-only\" phone numbers.\n      // case 'IS_POSSIBLE_LOCAL_ONLY':\n      return false;\n    default:\n      return true;\n  }\n}\n//# sourceMappingURL=extractNationalNumber.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","e","__esModule","Object","defineProperty","value","extractNationalNumber","number","country","metadata","_extractNationalNumbe","_extractNationalNumberFromPossiblyIncompleteNumber","carrierCode","nationalNumber","_matchesEntirely","nationalNumberPattern","numberingPlan","possibleLengths","_getCountryByCallingCode","callingCode","_checkNumberLength"]
}

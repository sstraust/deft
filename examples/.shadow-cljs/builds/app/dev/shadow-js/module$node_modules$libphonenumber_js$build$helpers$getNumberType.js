["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/libphonenumber-js/build/helpers/getNumberType.js"],"~:js","shadow$provide.module$node_modules$libphonenumber_js$build$helpers$getNumberType = function(global, require, module, exports) {\n  function _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\"default\":e};\n  }\n  function _createForOfIteratorHelperLoose(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (t) {\n      return (t = t.call(r)).next.bind(t);\n    }\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var o = 0;\n      return function() {\n        return o >= r.length ? {done:!0} : {done:!1, value:r[o++]};\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) {\n        return _arrayLikeToArray(r, a);\n      }\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  }\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) {\n      n[e] = r[e];\n    }\n    return n;\n  }\n  function isNumberTypeEqualTo(nationalNumber, type, metadata) {\n    type = metadata.type(type);\n    return !type || !type.pattern() || type.possibleLengths() && 0 > type.possibleLengths().indexOf(nationalNumber.length) ? !1 : (0,_matchesEntirely[\"default\"])(nationalNumber, type.pattern());\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports[\"default\"] = function(input, options, metadata) {\n    options = options || {};\n    if (input.country || input.countryCallingCode) {\n      if (metadata = new _metadata[\"default\"](metadata), metadata.selectNumberingPlan(input.country, input.countryCallingCode), input = options.v2 ? input.nationalNumber : input.phone, (0,_matchesEntirely[\"default\"])(input, metadata.nationalNumberPattern())) {\n        if (isNumberTypeEqualTo(input, \"FIXED_LINE\", metadata)) {\n          return metadata.type(\"MOBILE\") && \"\" === metadata.type(\"MOBILE\").pattern() || !metadata.type(\"MOBILE\") || isNumberTypeEqualTo(input, \"MOBILE\", metadata) ? \"FIXED_LINE_OR_MOBILE\" : \"FIXED_LINE\";\n        }\n        options = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES);\n        for (var _step; !(_step = options()).done;) {\n          if (_step = _step.value, isNumberTypeEqualTo(input, _step, metadata)) {\n            return _step;\n          }\n        }\n      }\n    }\n  };\n  exports.isNumberTypeEqualTo = isNumberTypeEqualTo;\n  var _metadata = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$metadata\")), _matchesEntirely = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$matchesEntirely\")), NON_FIXED_LINE_PHONE_TYPES = \"MOBILE PREMIUM_RATE TOLL_FREE SHARED_COST VOIP PERSONAL_NUMBER PAGER UAN VOICEMAIL\".split(\" \");\n};\n","~:source","shadow$provide[\"module$node_modules$libphonenumber_js$build$helpers$getNumberType\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getNumberType;\nexports.isNumberTypeEqualTo = isNumberTypeEqualTo;\nvar _metadata = _interopRequireDefault(require(\"../metadata.js\"));\nvar _matchesEntirely = _interopRequireDefault(require(\"./matchesEntirely.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL'];\n\n// Finds out national phone number type (fixed line, mobile, etc)\nfunction getNumberType(input, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n\n  // When `parse()` returns an empty object — `{}` —\n  // that means that the phone number is malformed,\n  // so it can't possibly be valid.\n  if (!input.country && !input.countryCallingCode) {\n    return;\n  }\n  metadata = new _metadata[\"default\"](metadata);\n  metadata.selectNumberingPlan(input.country, input.countryCallingCode);\n  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;\n\n  // The following is copy-pasted from the original function:\n  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n  // Is this national number even valid for this country\n  if (!(0, _matchesEntirely[\"default\"])(nationalNumber, metadata.nationalNumberPattern())) {\n    return;\n  }\n\n  // Is it fixed line number\n  if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\n    // Because duplicate regular expressions are removed\n    // to reduce metadata size, if \"mobile\" pattern is \"\"\n    // then it means it was removed due to being a duplicate of the fixed-line pattern.\n    //\n    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n\n    // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\n    // For example, for \"US\" country.\n    // Old metadata (< `1.0.18`) had a specific \"types\" data structure\n    // that happened to be `undefined` for `MOBILE` in that case.\n    // Newer metadata (>= `1.0.18`) has another data structure that is\n    // not `undefined` for `MOBILE` in that case (it's just an empty array).\n    // So this `if` is just for backwards compatibility with old metadata.\n    if (!metadata.type('MOBILE')) {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n\n    // Check if the number happens to qualify as both fixed line and mobile.\n    // (no such country in the minimal metadata set)\n    /* istanbul ignore if */\n    if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n    return 'FIXED_LINE';\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;) {\n    var type = _step.value;\n    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\n      return type;\n    }\n  }\n}\nfunction isNumberTypeEqualTo(nationalNumber, type, metadata) {\n  type = metadata.type(type);\n  if (!type || !type.pattern()) {\n    return false;\n  }\n  // Check if any possible number lengths are present;\n  // if so, we use them to avoid checking\n  // the validation pattern if they don't match.\n  // If they are absent, this means they match\n  // the general description, which we have\n  // already checked before a specific number type.\n  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {\n    return false;\n  }\n  return (0, _matchesEntirely[\"default\"])(nationalNumber, type.pattern());\n}\n//# sourceMappingURL=getNumberType.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$libphonenumber_js$build$metadata","~$shadow.js","~$module$node_modules$libphonenumber_js$build$helpers$matchesEntirely"]],"~:properties",["^5",["__esModule","isNumberTypeEqualTo","value","done"]],"~:compiled-at",1760720685896,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$libphonenumber_js$build$helpers$getNumberType.js\",\n\"lineCount\":59,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/libphonenumber-js/build/helpers/getNumberType.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$libphonenumber_js$build$helpers$getNumberType\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = getNumberType;\\nexports.isNumberTypeEqualTo = isNumberTypeEqualTo;\\nvar _metadata = _interopRequireDefault(require(\\\"../metadata.js\\\"));\\nvar _matchesEntirely = _interopRequireDefault(require(\\\"./matchesEntirely.js\\\"));\\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \\\"default\\\": e }; }\\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \\\"undefined\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\"@@iterator\\\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \\\"number\\\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\\\"string\\\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \\\"Object\\\" === t && r.constructor && (t = r.constructor.name), \\\"Map\\\" === t || \\\"Set\\\" === t ? Array.from(r) : \\\"Arguments\\\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\\nvar NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL'];\\n\\n// Finds out national phone number type (fixed line, mobile, etc)\\nfunction getNumberType(input, options, metadata) {\\n  // If assigning the `{}` default value is moved to the arguments above,\\n  // code coverage would decrease for some weird reason.\\n  options = options || {};\\n\\n  // When `parse()` returns an empty object \\u2014 `{}` \\u2014\\n  // that means that the phone number is malformed,\\n  // so it can't possibly be valid.\\n  if (!input.country && !input.countryCallingCode) {\\n    return;\\n  }\\n  metadata = new _metadata[\\\"default\\\"](metadata);\\n  metadata.selectNumberingPlan(input.country, input.countryCallingCode);\\n  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;\\n\\n  // The following is copy-pasted from the original function:\\n  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\\n\\n  // Is this national number even valid for this country\\n  if (!(0, _matchesEntirely[\\\"default\\\"])(nationalNumber, metadata.nationalNumberPattern())) {\\n    return;\\n  }\\n\\n  // Is it fixed line number\\n  if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\\n    // Because duplicate regular expressions are removed\\n    // to reduce metadata size, if \\\"mobile\\\" pattern is \\\"\\\"\\n    // then it means it was removed due to being a duplicate of the fixed-line pattern.\\n    //\\n    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\\n      return 'FIXED_LINE_OR_MOBILE';\\n    }\\n\\n    // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\\n    // For example, for \\\"US\\\" country.\\n    // Old metadata (< `1.0.18`) had a specific \\\"types\\\" data structure\\n    // that happened to be `undefined` for `MOBILE` in that case.\\n    // Newer metadata (>= `1.0.18`) has another data structure that is\\n    // not `undefined` for `MOBILE` in that case (it's just an empty array).\\n    // So this `if` is just for backwards compatibility with old metadata.\\n    if (!metadata.type('MOBILE')) {\\n      return 'FIXED_LINE_OR_MOBILE';\\n    }\\n\\n    // Check if the number happens to qualify as both fixed line and mobile.\\n    // (no such country in the minimal metadata set)\\n    /* istanbul ignore if */\\n    if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\\n      return 'FIXED_LINE_OR_MOBILE';\\n    }\\n    return 'FIXED_LINE';\\n  }\\n  for (var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;) {\\n    var type = _step.value;\\n    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\\n      return type;\\n    }\\n  }\\n}\\nfunction isNumberTypeEqualTo(nationalNumber, type, metadata) {\\n  type = metadata.type(type);\\n  if (!type || !type.pattern()) {\\n    return false;\\n  }\\n  // Check if any possible number lengths are present;\\n  // if so, we use them to avoid checking\\n  // the validation pattern if they don't match.\\n  // If they are absent, this means they match\\n  // the general description, which we have\\n  // already checked before a specific number type.\\n  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {\\n    return false;\\n  }\\n  return (0, _matchesEntirely[\\\"default\\\"])(nationalNumber, type.pattern());\\n}\\n//# sourceMappingURL=getNumberType.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"e\",\"__esModule\",\"_createForOfIteratorHelperLoose\",\"r\",\"t\",\"Symbol\",\"iterator\",\"next\",\"call\",\"bind\",\"Array\",\"isArray\",\"_unsupportedIterableToArray\",\"length\",\"o\",\"done\",\"value\",\"TypeError\",\"a\",\"_arrayLikeToArray\",\"toString\",\"slice\",\"constructor\",\"name\",\"from\",\"test\",\"n\",\"isNumberTypeEqualTo\",\"nationalNumber\",\"type\",\"metadata\",\"pattern\",\"possibleLengths\",\"indexOf\",\"_matchesEntirely\",\"Object\",\"defineProperty\",\"getNumberType\",\"input\",\"options\",\"country\",\"countryCallingCode\",\"_metadata\",\"selectNumberingPlan\",\"v2\",\"phone\",\"nationalNumberPattern\",\"_iterator\",\"NON_FIXED_LINE_PHONE_TYPES\",\"_step\"]\n}\n"]
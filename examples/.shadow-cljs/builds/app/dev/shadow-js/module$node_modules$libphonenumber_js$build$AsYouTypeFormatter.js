["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/libphonenumber-js/build/AsYouTypeFormatter.js"],"~:js","shadow$provide.module$node_modules$libphonenumber_js$build$AsYouTypeFormatter = function(global, require, module, exports) {\n  function _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\"default\":e};\n  }\n  function _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) {\n      var r = new WeakMap(), n = new WeakMap();\n    }\n    return (_interopRequireWildcard = function(e, t) {\n      if (!t && e && e.__esModule) {\n        return e;\n      }\n      var i, f = {__proto__:null, \"default\":e};\n      if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) {\n        return f;\n      }\n      if (t = t ? n : r) {\n        if (t.has(e)) {\n          return t.get(e);\n        }\n        t.set(e, f);\n      }\n      for (var _t in e) {\n        \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (t = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? t(f, _t, i) : f[_t] = e[_t]);\n      }\n      return f;\n    })(e, t);\n  }\n  function _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n      return typeof o;\n    } : function(o) {\n      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n  }\n  function _createForOfIteratorHelperLoose(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (t) {\n      return (t = t.call(r)).next.bind(t);\n    }\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var o = 0;\n      return function() {\n        return o >= r.length ? {done:!0} : {done:!1, value:r[o++]};\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) {\n        return _arrayLikeToArray(r, a);\n      }\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  }\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) {\n      n[e] = r[e];\n    }\n    return n;\n  }\n  function _defineProperties(e$jscomp$0, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1;\n      o.configurable = !0;\n      \"value\" in o && (o.writable = !0);\n      var JSCompiler_temp_const = Object, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.defineProperty;\n      a: {\n        var JSCompiler_inline_result = o.key;\n        if (\"object\" == _typeof(JSCompiler_inline_result) && JSCompiler_inline_result) {\n          var e = JSCompiler_inline_result[Symbol.toPrimitive];\n          if (void 0 !== e) {\n            JSCompiler_inline_result = e.call(JSCompiler_inline_result, \"string\");\n            if (\"object\" != _typeof(JSCompiler_inline_result)) {\n              break a;\n            }\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          JSCompiler_inline_result = String(JSCompiler_inline_result);\n        }\n      }\n      JSCompiler_inline_result = \"symbol\" == _typeof(JSCompiler_inline_result) ? JSCompiler_inline_result : JSCompiler_inline_result + \"\";\n      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, e$jscomp$0, JSCompiler_inline_result, o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {writable:!1}), e;\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  Object.defineProperty(exports, \"DIGIT_PLACEHOLDER\", {enumerable:!0, get:function() {\n    return _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER;\n  }});\n  exports[\"default\"] = void 0;\n  var _AsYouTypeFormatterUtil = require(\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_util\"), _AsYouTypeFormatterComplete = _interopRequireWildcard(require(\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_complete\")), _AsYouTypeFormatterPatternMatcher = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternMatcher\")), _parseDigits = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$parseDigits\")), \n  _formatNationalNumberUsingFormat = require(\"module$node_modules$libphonenumber_js$build$helpers$formatNationalNumberUsingFormat\");\n  global = require(\"module$node_modules$libphonenumber_js$build$constants\");\n  var _applyInternationalSeparatorStyle = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$applyInternationalSeparatorStyle\")), LONGEST_DUMMY_PHONE_NUMBER = (0,_AsYouTypeFormatterUtil.repeat)(\"9\", 15), NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/, NON_ALTERING_FORMAT_REG_EXP = new RegExp(\"[\" + global.VALID_PUNCTUATION + \"]*\\\\$1[\" + global.VALID_PUNCTUATION + \"]*(\\\\$\\\\d[\" + global.VALID_PUNCTUATION + \"]*)*$\");\n  exports[\"default\"] = function() {\n    function AsYouTypeFormatter(_ref) {\n      _ref = _ref.metadata;\n      if (!(this instanceof AsYouTypeFormatter)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n      this.metadata = _ref;\n      this.resetFormat();\n    }\n    return _createClass(AsYouTypeFormatter, [{key:\"resetFormat\", value:function() {\n      this.populatedNationalNumberTemplate = this.nationalNumberTemplate = this.template = this.chosenFormat = void 0;\n      this.populatedNationalNumberTemplatePosition = -1;\n    }}, {key:\"reset\", value:function(numberingPlan, state) {\n      this.resetFormat();\n      numberingPlan ? (this.isNANP = \"1\" === numberingPlan.callingCode(), this.matchingFormats = numberingPlan.formats(), state.nationalSignificantNumber && this.narrowDownMatchingFormats(state)) : (this.isNANP = void 0, this.matchingFormats = []);\n    }}, {key:\"format\", value:function(nextDigits, state) {\n      var _this = this;\n      if ((0,_AsYouTypeFormatterComplete.canFormatCompleteNumber)(state.nationalSignificantNumber, state.country, this.metadata)) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\n          _step = _step.value;\n          var formattedCompleteNumber = (0,_AsYouTypeFormatterComplete[\"default\"])(state, _step, {metadata:this.metadata, shouldTryNationalPrefixFormattingRule:function(format) {\n            return _this.shouldTryNationalPrefixFormattingRule(format, {international:state.international, nationalPrefix:state.nationalPrefix});\n          }, getSeparatorAfterNationalPrefix:function(format) {\n            return _this.getSeparatorAfterNationalPrefix(format);\n          }});\n          if (formattedCompleteNumber) {\n            return this.resetFormat(), this.chosenFormat = _step, this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), state), this.populatedNationalNumberTemplate = formattedCompleteNumber, this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), formattedCompleteNumber;\n          }\n        }\n      }\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\n    }}, {key:\"formatNationalNumberWithNextDigits\", value:function(nextDigits, state) {\n      var previouslyChosenFormat = this.chosenFormat, newlyChosenFormat = this.chooseFormat(state);\n      if (newlyChosenFormat) {\n        return newlyChosenFormat === previouslyChosenFormat ? this.formatNextNationalNumberDigits(nextDigits) : this.formatNextNationalNumberDigits(state.getNationalDigits());\n      }\n    }}, {key:\"narrowDownMatchingFormats\", value:function(_ref2) {\n      var _this2 = this, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international, leadingDigits = _ref2.nationalSignificantNumber, leadingDigitsPatternIndex = leadingDigits.length - 3;\n      0 > leadingDigitsPatternIndex && (leadingDigitsPatternIndex = 0);\n      this.matchingFormats = this.matchingFormats.filter(function(format) {\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\n      });\n      this.chosenFormat && -1 === this.matchingFormats.indexOf(this.chosenFormat) && this.resetFormat();\n    }}, {key:\"formatSuits\", value:function(format, international, nationalPrefix) {\n      return nationalPrefix && !format.usesNationalPrefix() && !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() || !international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat() ? !1 : !0;\n    }}, {key:\"formatMatches\", value:function(format, leadingDigits, leadingDigitsPatternIndex) {\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;\n      if (0 === leadingDigitsPatternsCount) {\n        return !0;\n      }\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\n      format = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];\n      if (3 > leadingDigits.length) {\n        try {\n          return void 0 !== (new _AsYouTypeFormatterPatternMatcher[\"default\"](format)).match(leadingDigits, {allowOverflow:!0});\n        } catch (error) {\n          return console.error(error), !0;\n        }\n      }\n      return (new RegExp(\"^(\".concat(format, \")\"))).test(leadingDigits);\n    }}, {key:\"getFormatFormat\", value:function(format, international) {\n      return international ? format.internationalFormat() : format.format();\n    }}, {key:\"chooseFormat\", value:function(state) {\n      for (var _this3 = this, _loop = function() {\n        var format = _step2.value;\n        if (_this3.chosenFormat === format) {\n          return 0;\n        }\n        if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\n          return 1;\n        }\n        if (!_this3.createTemplateForFormat(format, state)) {\n          return _this3.matchingFormats = _this3.matchingFormats.filter(function(_) {\n            return _ !== format;\n          }), 1;\n        }\n        _this3.chosenFormat = format;\n        return 0;\n      }, _ret, _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done && (_ret = _loop(), 0 !== _ret);) {\n      }\n      this.chosenFormat || this.resetFormat();\n      return this.chosenFormat;\n    }}, {key:\"createTemplateForFormat\", value:function(format, state) {\n      if (!(0 <= format.pattern().indexOf(\"|\")) && (format = this.getTemplateForFormat(format, state))) {\n        return this.setNationalNumberTemplate(format, state), !0;\n      }\n    }}, {key:\"getSeparatorAfterNationalPrefix\", value:function(format) {\n      return this.isNANP || format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule()) ? \" \" : \"\";\n    }}, {key:\"getInternationalPrefixBeforeCountryCallingCode\", value:function(_ref3, options) {\n      var IDDPrefix = _ref3.IDDPrefix;\n      return IDDPrefix ? options && !1 === options.spacing ? IDDPrefix : IDDPrefix + \" \" : _ref3.missingPlus ? \"\" : \"+\";\n    }}, {key:\"getTemplate\", value:function(state) {\n      if (this.template) {\n        for (var index = -1, i = 0, internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {spacing:!1}) : \"\"; i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length;) {\n          index = this.template.indexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, index + 1), i++;\n        }\n        return (0,_AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.template, index + 1);\n      }\n    }}, {key:\"setNationalNumberTemplate\", value:function(template, state) {\n      this.populatedNationalNumberTemplate = this.nationalNumberTemplate = template;\n      this.populatedNationalNumberTemplatePosition = -1;\n      this.template = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER) + (0,_AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, state.callingCode.length) + \" \" + template : template;\n    }}, {key:\"getTemplateForFormat\", value:function(format, _ref4) {\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix;\n      _ref4 = _ref4.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\n      var pattern = format.pattern();\n      pattern = pattern.replace(/\\[([^\\[\\]])*\\]/g, \"\\\\d\").replace(/\\d(?=[^,}][^,}])/g, \"\\\\d\");\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];\n      if (!(nationalSignificantNumber.length > digits.length)) {\n        var strictPattern = new RegExp(\"^\" + pattern + \"$\");\n        nationalSignificantNumber = nationalSignificantNumber.replace(/\\d/g, \"9\");\n        strictPattern.test(nationalSignificantNumber) && (digits = nationalSignificantNumber);\n        nationalSignificantNumber = this.getFormatFormat(format, international);\n        if (this.shouldTryNationalPrefixFormattingRule(format, {international, nationalPrefix}) && (strictPattern = nationalSignificantNumber.replace(_formatNationalNumberUsingFormat.FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()), (0,_parseDigits[\"default\"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || \"\") + (0,_parseDigits[\"default\"])(\"$1\"))) {\n          nationalSignificantNumber = strictPattern;\n          var nationalPrefixIncludedInTemplate = !0;\n          if (nationalPrefix) {\n            for (strictPattern = nationalPrefix.length; 0 < strictPattern;) {\n              nationalSignificantNumber = nationalSignificantNumber.replace(/\\d/, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), strictPattern--;\n            }\n          }\n        }\n        pattern = digits.replace(new RegExp(pattern), nationalSignificantNumber).replace(RegExp(\"9\", \"g\"), _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n        nationalPrefixIncludedInTemplate || (_ref4 ? pattern = (0,_AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, _ref4.length) + \" \" + pattern : nationalPrefix && (pattern = (0,_AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + pattern));\n        international && (pattern = (0,_applyInternationalSeparatorStyle[\"default\"])(pattern));\n        return pattern;\n      }\n    }}, {key:\"formatNextNationalNumberDigits\", value:function(digits) {\n      if (digits = (0,_AsYouTypeFormatterUtil.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits)) {\n        return this.populatedNationalNumberTemplate = digits[0], this.populatedNationalNumberTemplatePosition = digits[1], (0,_AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);\n      }\n      this.resetFormat();\n    }}, {key:\"shouldTryNationalPrefixFormattingRule\", value:function(format, _ref5) {\n      var international = _ref5.international;\n      _ref5 = _ref5.nationalPrefix;\n      if (format.nationalPrefixFormattingRule() && ((format = format.usesNationalPrefix()) && _ref5 || !format && !international)) {\n        return !0;\n      }\n    }}]);\n  }();\n};\n","~:source","shadow$provide[\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DIGIT_PLACEHOLDER\", {\n  enumerable: true,\n  get: function get() {\n    return _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER;\n  }\n});\nexports[\"default\"] = void 0;\nvar _AsYouTypeFormatterUtil = require(\"./AsYouTypeFormatter.util.js\");\nvar _AsYouTypeFormatterComplete = _interopRequireWildcard(require(\"./AsYouTypeFormatter.complete.js\"));\nvar _AsYouTypeFormatterPatternMatcher = _interopRequireDefault(require(\"./AsYouTypeFormatter.PatternMatcher.js\"));\nvar _parseDigits = _interopRequireDefault(require(\"./helpers/parseDigits.js\"));\nvar _formatNationalNumberUsingFormat = require(\"./helpers/formatNationalNumberUsingFormat.js\");\nvar _constants = require(\"./constants.js\");\nvar _applyInternationalSeparatorStyle = _interopRequireDefault(require(\"./helpers/applyInternationalSeparatorStyle.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, \"default\": e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nvar DUMMY_DIGIT = '9';\n// I don't know why is it exactly `15`\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;\n// Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\nvar LONGEST_DUMMY_PHONE_NUMBER = (0, _AsYouTypeFormatterUtil.repeat)(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);\n\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\n// us that we should separate the national prefix from the number when formatting.\nvar NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;\n\n// Deprecated: Google has removed some formatting pattern related code from their repo.\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\n// Because this library supports generating custom metadata\n// some users may still be using old metadata so the relevant\n// code seems to stay until some next major version update.\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true;\n\n// A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\[([^\\[\\]])*\\]/g;\n};\n\n// Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\d(?=[^,}][^,}])/g;\n};\n\n// A regular expression that is used to determine if a `format` is\n// suitable to be used in the \"as you type formatter\".\n// A `format` is suitable when the resulting formatted number has\n// the same digits as the user has entered.\n//\n// In the simplest case, that would mean that the format\n// doesn't add any additional digits when formatting a number.\n// Google says that it also shouldn't add \"star\" (`*`) characters,\n// like it does in some Israeli formats.\n// Such basic format would only contain \"valid punctuation\"\n// and \"captured group\" identifiers ($1, $2, etc).\n//\n// An example of a format that adds additional digits:\n//\n// Country: `AR` (Argentina).\n// Format:\n// {\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n//    \"leading_digits_patterns\": [\"91\"],\n//    \"national_prefix_formatting_rule\": \"0$1\",\n//    \"format\": \"$2 15-$3-$4\",\n//    \"international_format\": \"$1 $2 $3-$4\"\n// }\n//\n// In the format above, the `format` adds `15` to the digits when formatting a number.\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\n// has previously removed `15` from a national number, so re-adding `15` in `format`\n// doesn't actually result in any extra digits added to user's input.\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\n//\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\n// `libphonenumber` code.\n//\nvar NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + _constants.VALID_PUNCTUATION + ']*' +\n// Google developers say:\n// \"We require that the first matching group is present in the\n//  output pattern to ensure no data is lost while formatting.\"\n'\\\\$1' + '[' + _constants.VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + _constants.VALID_PUNCTUATION + ']*)*' + '$');\n\n// This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\nvar MIN_LEADING_DIGITS_LENGTH = 3;\nvar AsYouTypeFormatter = exports[\"default\"] = /*#__PURE__*/function () {\n  function AsYouTypeFormatter(_ref) {\n    var state = _ref.state,\n      metadata = _ref.metadata;\n    _classCallCheck(this, AsYouTypeFormatter);\n    this.metadata = metadata;\n    this.resetFormat();\n  }\n  return _createClass(AsYouTypeFormatter, [{\n    key: \"resetFormat\",\n    value: function resetFormat() {\n      this.chosenFormat = undefined;\n      this.template = undefined;\n      this.nationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplatePosition = -1;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan, state) {\n      this.resetFormat();\n      if (numberingPlan) {\n        this.isNANP = numberingPlan.callingCode() === '1';\n        this.matchingFormats = numberingPlan.formats();\n        if (state.nationalSignificantNumber) {\n          this.narrowDownMatchingFormats(state);\n        }\n      } else {\n        this.isNANP = undefined;\n        this.matchingFormats = [];\n      }\n    }\n\n    /**\r\n     * Formats an updated phone number.\r\n     * @param  {string} nextDigits — Additional phone number digits.\r\n     * @param  {object} state — `AsYouType` state.\r\n     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n     */\n  }, {\n    key: \"format\",\n    value: function format(nextDigits, state) {\n      var _this = this;\n      // See if the phone number digits can be formatted as a complete phone number.\n      // If not, use the results from `formatNationalNumberWithNextDigits()`,\n      // which formats based on the chosen formatting pattern.\n      //\n      // Attempting to format complete phone number first is how it's done\n      // in Google's `libphonenumber`, so this library just follows it.\n      // Google's `libphonenumber` code doesn't explain in detail why does it\n      // attempt to format digits as a complete phone number\n      // instead of just going with a previoulsy (or newly) chosen `format`:\n      //\n      // \"Checks to see if there is an exact pattern match for these digits.\n      //  If so, we should use this instead of any other formatting template\n      //  whose leadingDigitsPattern also matches the input.\"\n      //\n      if ((0, _AsYouTypeFormatterComplete.canFormatCompleteNumber)(state.nationalSignificantNumber, state.country, this.metadata)) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\n          var _format = _step.value;\n          var formattedCompleteNumber = (0, _AsYouTypeFormatterComplete[\"default\"])(state, _format, {\n            metadata: this.metadata,\n            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {\n              return _this.shouldTryNationalPrefixFormattingRule(format, {\n                international: state.international,\n                nationalPrefix: state.nationalPrefix\n              });\n            },\n            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {\n              return _this.getSeparatorAfterNationalPrefix(format);\n            }\n          });\n          if (formattedCompleteNumber) {\n            this.resetFormat();\n            this.chosenFormat = _format;\n            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), state);\n            this.populatedNationalNumberTemplate = formattedCompleteNumber;\n            // With a new formatting template, the matched position\n            // using the old template needs to be reset.\n            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n            return formattedCompleteNumber;\n          }\n        }\n      }\n      // Format the digits as a partial (incomplete) phone number\n      // using the previously chosen formatting pattern (or a newly chosen one).\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\n    }\n\n    // Formats the next phone number digits.\n  }, {\n    key: \"formatNationalNumberWithNextDigits\",\n    value: function formatNationalNumberWithNextDigits(nextDigits, state) {\n      var previouslyChosenFormat = this.chosenFormat;\n\n      // Choose a format from the list of matching ones.\n      var newlyChosenFormat = this.chooseFormat(state);\n      if (newlyChosenFormat) {\n        if (newlyChosenFormat === previouslyChosenFormat) {\n          // If it can format the next (current) digits\n          // using the previously chosen phone number format\n          // then return the updated formatted number.\n          return this.formatNextNationalNumberDigits(nextDigits);\n        } else {\n          // If a more appropriate phone number format\n          // has been chosen for these \"leading digits\",\n          // then re-format the national phone number part\n          // using the newly selected format.\n          return this.formatNextNationalNumberDigits(state.getNationalDigits());\n        }\n      }\n    }\n  }, {\n    key: \"narrowDownMatchingFormats\",\n    value: function narrowDownMatchingFormats(_ref2) {\n      var _this2 = this;\n      var nationalSignificantNumber = _ref2.nationalSignificantNumber,\n        nationalPrefix = _ref2.nationalPrefix,\n        international = _ref2.international;\n      var leadingDigits = nationalSignificantNumber;\n\n      // \"leading digits\" pattern list starts with a\n      // \"leading digits\" pattern fitting a maximum of 3 leading digits.\n      // So, after a user inputs 3 digits of a national (significant) phone number\n      // this national (significant) number can already be formatted.\n      // The next \"leading digits\" pattern is for 4 leading digits max,\n      // and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\n\n      // This implementation is different from Google's\n      // in that it searches for a fitting format\n      // even if the user has entered less than\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\n      // Because some leading digit patterns already match for a single first digit.\n      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;\n      if (leadingDigitsPatternIndex < 0) {\n        leadingDigitsPatternIndex = 0;\n      }\n      this.matchingFormats = this.matchingFormats.filter(function (format) {\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\n      });\n\n      // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      // To construct a valid test case for this one can find a country\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\n      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\n        this.resetFormat();\n      }\n    }\n  }, {\n    key: \"formatSuits\",\n    value: function formatSuits(format, international, nationalPrefix) {\n      // When a prefix before a national (significant) number is\n      // simply a national prefix, then it's parsed as `this.nationalPrefix`.\n      // In more complex cases, a prefix before national (significant) number\n      // could include a national prefix as well as some \"capturing groups\",\n      // and in that case there's no info whether a national prefix has been parsed.\n      // If national prefix is not used when formatting a phone number\n      // using this format, but a national prefix has been entered by the user,\n      // and was extracted, then discard such phone number format.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\n      if (nationalPrefix && !format.usesNationalPrefix() &&\n      // !format.domesticCarrierCodeFormattingRule() &&\n      !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n        return false;\n      }\n      // If national prefix is mandatory for this phone number format\n      // and there're no guarantees that a national prefix is present in user input\n      // then discard this phone number format as not suitable.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\n      if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"formatMatches\",\n    value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;\n\n      // If this format is not restricted to a certain\n      // leading digits pattern then it fits.\n      // The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\n      if (leadingDigitsPatternsCount === 0) {\n        return true;\n      }\n\n      // Start narrowing down the list of possible formats based on the leading digits.\n      // (only previously matched formats take part in the narrowing down process)\n\n      // `leading_digits_patterns` start with 3 digits min\n      // and then go up from there one digit at a time.\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\n      var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];\n\n      // Google imposes a requirement on the leading digits\n      // to be minimum 3 digits long in order to be eligible\n      // for checking those with a leading digits pattern.\n      //\n      // Since `leading_digits_patterns` start with 3 digits min,\n      // Google's original `libphonenumber` library only starts\n      // excluding any non-matching formats only when the\n      // national number entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives.\n      //\n      // For example, when the digits entered so far are `2`\n      // and the leading digits pattern is `21` –\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Also, `leading_digits_patterns` doesn't always correspond to a single\n      // digits count. For example, `60|8` pattern would already match `8`\n      // but the `60` part would require having at least two leading digits,\n      // so the whole pattern would require inputting two digits first in order to\n      // decide on whether it matches the input, even when the input is \"80\".\n      //\n      // This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`\n      // even when there's only 1 or 2 digits of the national (significant) number.\n      // To do that, it uses a non-strict pattern matcher written specifically for that.\n      //\n      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\n        // Before leading digits < 3 matching was implemented:\n        // return true\n        //\n        // After leading digits < 3 matching was implemented:\n        try {\n          return new _AsYouTypeFormatterPatternMatcher[\"default\"](leadingDigitsPattern).match(leadingDigits, {\n            allowOverflow: true\n          }) !== undefined;\n        } catch (error) /* istanbul ignore next */{\n          // There's a slight possibility that there could be some undiscovered bug\n          // in the pattern matcher code. Since the \"leading digits < 3 matching\"\n          // feature is not \"essential\" for operation, it can fall back to the old way\n          // in case of any issues rather than halting the application's execution.\n          console.error(error);\n          return true;\n        }\n      }\n\n      // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\n      // available then use the usual regular expression matching.\n      //\n      // The whole pattern is wrapped in round brackets (`()`) because\n      // the pattern can use \"or\" operator (`|`) at the top level of the pattern.\n      //\n      return new RegExp(\"^(\".concat(leadingDigitsPattern, \")\")).test(leadingDigits);\n    }\n  }, {\n    key: \"getFormatFormat\",\n    value: function getFormatFormat(format, international) {\n      return international ? format.internationalFormat() : format.format();\n    }\n  }, {\n    key: \"chooseFormat\",\n    value: function chooseFormat(state) {\n      var _this3 = this;\n      var _loop = function _loop() {\n          var format = _step2.value;\n          // If this format is currently being used\n          // and is still suitable, then stick to it.\n          if (_this3.chosenFormat === format) {\n            return 0; // break\n          }\n          // Sometimes, a formatting rule inserts additional digits in a phone number,\n          // and \"as you type\" formatter can't do that: it should only use the digits\n          // that the user has input.\n          //\n          // For example, in Argentina, there's a format for mobile phone numbers:\n          //\n          // {\n          //    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n          //    \"leading_digits_patterns\": [\"91\"],\n          //    \"national_prefix_formatting_rule\": \"0$1\",\n          //    \"format\": \"$2 15-$3-$4\",\n          //    \"international_format\": \"$1 $2 $3-$4\"\n          // }\n          //\n          // In that format, `international_format` is used instead of `format`\n          // because `format` inserts `15` in the formatted number,\n          // and `AsYouType` formatter should only use the digits\n          // the user has actually input, without adding any extra digits.\n          // In this case, it wouldn't make a difference, because the `15`\n          // is first stripped when applying `national_prefix_for_parsing`\n          // and then re-added when using `format`, so in reality it doesn't\n          // add any new digits to the number, but to detect that, the code\n          // would have to be more complex: it would have to try formatting\n          // the digits using the format and then see if any digits have\n          // actually been added or removed, and then, every time a new digit\n          // is input, it should re-check whether the chosen format doesn't\n          // alter the digits.\n          //\n          // Google's code doesn't go that far, and so does this library:\n          // it simply requires that a `format` doesn't add any additonal\n          // digits to user's input.\n          //\n          // Also, people in general should move from inputting phone numbers\n          // in national format (possibly with national prefixes)\n          // and use international phone number format instead:\n          // it's a logical thing in the modern age of mobile phones,\n          // globalization and the internet.\n          //\n          /* istanbul ignore if */\n          if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\n            return 1; // continue\n          }\n          if (!_this3.createTemplateForFormat(format, state)) {\n            // Remove the format if it can't generate a template.\n            _this3.matchingFormats = _this3.matchingFormats.filter(function (_) {\n              return _ !== format;\n            });\n            return 1; // continue\n          }\n          _this3.chosenFormat = format;\n          return 0; // break\n        },\n        _ret;\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      //\n      // For some weird reason, `istanbul` says \"else path not taken\"\n      // for the `for of` line below. Supposedly that means that\n      // the loop doesn't ever go over the last element in the list.\n      // That's true because there always is `this.chosenFormat`\n      // when `this.matchingFormats` is non-empty.\n      // And, for some weird reason, it doesn't think that the case\n      // with empty `this.matchingFormats` qualifies for a valid \"else\" path.\n      // So simply muting this `istanbul` warning.\n      // It doesn't skip the contents of the `for of` loop,\n      // it just skips the `for of` line.\n      //\n      /* istanbul ignore next */\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;) {\n        _ret = _loop();\n        if (_ret === 0) break;\n        if (_ret === 1) continue;\n      }\n      if (!this.chosenFormat) {\n        // No format matches the national (significant) phone number.\n        this.resetFormat();\n      }\n      return this.chosenFormat;\n    }\n  }, {\n    key: \"createTemplateForFormat\",\n    value: function createTemplateForFormat(format, state) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n      /* istanbul ignore if */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\n        return;\n      }\n      // Get formatting template for this phone number format\n      var template = this.getTemplateForFormat(format, state);\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (template) {\n        this.setNationalNumberTemplate(template, state);\n        return true;\n      }\n    }\n  }, {\n    key: \"getSeparatorAfterNationalPrefix\",\n    value: function getSeparatorAfterNationalPrefix(format) {\n      // `US` metadata doesn't have a `national_prefix_formatting_rule`,\n      // so the `if` condition below doesn't apply to `US`,\n      // but in reality there shoudl be a separator\n      // between a national prefix and a national (significant) number.\n      // So `US` national prefix separator is a \"special\" \"hardcoded\" case.\n      if (this.isNANP) {\n        return ' ';\n      }\n      // If a `format` has a `national_prefix_formatting_rule`\n      // and that rule has a separator after a national prefix,\n      // then it means that there should be a separator\n      // between a national prefix and a national (significant) number.\n      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\n        return ' ';\n      }\n      // At this point, there seems to be no clear evidence that\n      // there should be a separator between a national prefix\n      // and a national (significant) number. So don't insert one.\n      return '';\n    }\n  }, {\n    key: \"getInternationalPrefixBeforeCountryCallingCode\",\n    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {\n      var IDDPrefix = _ref3.IDDPrefix,\n        missingPlus = _ref3.missingPlus;\n      if (IDDPrefix) {\n        return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';\n      }\n      if (missingPlus) {\n        return '';\n      }\n      return '+';\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(state) {\n      if (!this.template) {\n        return;\n      }\n      // `this.template` holds the template for a \"complete\" phone number.\n      // The currently entered phone number is most likely not \"complete\",\n      // so trim all non-populated digits.\n      var index = -1;\n      var i = 0;\n      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {\n        spacing: false\n      }) : '';\n      while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\n        index = this.template.indexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, index + 1);\n        i++;\n      }\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.template, index + 1);\n    }\n  }, {\n    key: \"setNationalNumberTemplate\",\n    value: function setNationalNumberTemplate(template, state) {\n      this.nationalNumberTemplate = template;\n      this.populatedNationalNumberTemplate = template;\n      // With a new formatting template, the matched position\n      // using the old template needs to be reset.\n      this.populatedNationalNumberTemplatePosition = -1;\n      // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n      if (state.international) {\n        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER) + (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, state.callingCode.length) + ' ' + template;\n      } else {\n        this.template = template;\n      }\n    }\n\n    /**\r\n     * Generates formatting template for a national phone number,\r\n     * optionally containing a national prefix, for a format.\r\n     * @param  {Format} format\r\n     * @param  {string} nationalPrefix\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getTemplateForFormat\",\n    value: function getTemplateForFormat(format, _ref4) {\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber,\n        international = _ref4.international,\n        nationalPrefix = _ref4.nationalPrefix,\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _ref4.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\n      var pattern = format.pattern();\n\n      /* istanbul ignore else */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\n        pattern = pattern\n        // Replace anything in the form of [..] with \\d\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\n        // Replace any standalone digit (not the one in `{}`) with \\d\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d');\n      }\n\n      // Generate a dummy national number (consisting of `9`s)\n      // that fits this format's `pattern`.\n      //\n      // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n      //\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];\n\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (nationalSignificantNumber.length > digits.length) {\n        return;\n      }\n\n      // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n\n      // Below `strictPattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strictPattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.nationalSignificantNumber : `111111111` (9 digits)\n      //\n      // pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // format : `$1 $2 $3`\n      // digits : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `pattern`.\n      //\n      // The fix is, if `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then `this.nationalSignificantNumber`\n      // is used instead of `digits`.\n\n      var strictPattern = new RegExp('^' + pattern + '$');\n      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT);\n\n      // If `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then use it\n      // instead of `digits`.\n      if (strictPattern.test(nationalNumberDummyDigits)) {\n        digits = nationalNumberDummyDigits;\n      }\n      var numberFormat = this.getFormatFormat(format, international);\n      var nationalPrefixIncludedInTemplate;\n\n      // If a user did input a national prefix (and that's guaranteed),\n      // and if a `format` does have a national prefix formatting rule,\n      // then see if that national prefix formatting rule\n      // prepends exactly the same national prefix the user has input.\n      // If that's the case, then use the `format` with the national prefix formatting rule.\n      // Otherwise, use  the `format` without the national prefix formatting rule,\n      // and prepend a national prefix manually to it.\n      if (this.shouldTryNationalPrefixFormattingRule(format, {\n        international: international,\n        nationalPrefix: nationalPrefix\n      })) {\n        var numberFormatWithNationalPrefix = numberFormat.replace(_formatNationalNumberUsingFormat.FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());\n        // If `national_prefix_formatting_rule` of a `format` simply prepends\n        // national prefix at the start of a national (significant) number,\n        // then such formatting can be used with `AsYouType` formatter.\n        // There seems to be no `else` case: everywhere in metadata,\n        // national prefix formatting rule is national prefix + $1,\n        // or `($1)`, in which case such format isn't even considered\n        // when the user has input a national prefix.\n        /* istanbul ignore else */\n        if ((0, _parseDigits[\"default\"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + (0, _parseDigits[\"default\"])('$1')) {\n          numberFormat = numberFormatWithNationalPrefix;\n          nationalPrefixIncludedInTemplate = true;\n          // Replace all digits of the national prefix in the formatting template\n          // with `DIGIT_PLACEHOLDER`s.\n          if (nationalPrefix) {\n            var i = nationalPrefix.length;\n            while (i > 0) {\n              numberFormat = numberFormat.replace(/\\d/, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n              i--;\n            }\n          }\n        }\n      }\n\n      // Generate formatting template for this phone number format.\n      var template = digits\n      // Format the dummy phone number according to the format.\n      .replace(new RegExp(pattern), numberFormat)\n      // Replace each dummy digit with a DIGIT_PLACEHOLDER.\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n\n      // If a prefix of a national (significant) number is not as simple\n      // as just a basic national prefix, then just prepend such prefix\n      // before the national (significant) number, optionally spacing\n      // the two with a whitespace.\n      if (!nationalPrefixIncludedInTemplate) {\n        if (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\n          // Prepend the prefix to the template manually.\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) + ' ' + template;\n        } else if (nationalPrefix) {\n          // Prepend national prefix to the template manually.\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;\n        }\n      }\n      if (international) {\n        template = (0, _applyInternationalSeparatorStyle[\"default\"])(template);\n      }\n      return template;\n    }\n  }, {\n    key: \"formatNextNationalNumberDigits\",\n    value: function formatNextNationalNumberDigits(digits) {\n      var result = (0, _AsYouTypeFormatterUtil.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);\n      if (!result) {\n        // Reset the format.\n        this.resetFormat();\n        return;\n      }\n      this.populatedNationalNumberTemplate = result[0];\n      this.populatedNationalNumberTemplatePosition = result[1];\n\n      // Return the formatted phone number so far.\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);\n\n      // The old way which was good for `input-format` but is not so good\n      // for `react-phone-number-input`'s default input (`InputBasic`).\n      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\n      // \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\n    }\n  }, {\n    key: \"shouldTryNationalPrefixFormattingRule\",\n    value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {\n      var international = _ref5.international,\n        nationalPrefix = _ref5.nationalPrefix;\n      if (format.nationalPrefixFormattingRule()) {\n        // In some countries, `national_prefix_formatting_rule` is `($1)`,\n        // so it applies even if the user hasn't input a national prefix.\n        // `format.usesNationalPrefix()` detects such cases.\n        var usesNationalPrefix = format.usesNationalPrefix();\n        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {\n          return true;\n        }\n      }\n    }\n  }]);\n}();\n//# sourceMappingURL=AsYouTypeFormatter.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_complete","~$module$node_modules$libphonenumber_js$build$helpers$parseDigits","~$shadow.js","~$module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_util","~$module$node_modules$libphonenumber_js$build$constants","~$module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternMatcher","~$module$node_modules$libphonenumber_js$build$helpers$formatNationalNumberUsingFormat","~$module$node_modules$libphonenumber_js$build$helpers$applyInternationalSeparatorStyle"]],"~:properties",["^5",["DIGIT_PLACEHOLDER","spacing","prototype","key","__esModule","matchingFormats","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","nationalNumberTemplate","configurable","isNANP","value","enumerable","chosenFormat","writable","metadata","template","getSeparatorAfterNationalPrefix","__proto__","shouldTryNationalPrefixFormattingRule","international","nationalPrefix","get","allowOverflow","done"]],"~:compiled-at",1760720685932,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter.js\",\n\"lineCount\":245,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/libphonenumber-js/build/AsYouTypeFormatter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nObject.defineProperty(exports, \\\"DIGIT_PLACEHOLDER\\\", {\\n  enumerable: true,\\n  get: function get() {\\n    return _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER;\\n  }\\n});\\nexports[\\\"default\\\"] = void 0;\\nvar _AsYouTypeFormatterUtil = require(\\\"./AsYouTypeFormatter.util.js\\\");\\nvar _AsYouTypeFormatterComplete = _interopRequireWildcard(require(\\\"./AsYouTypeFormatter.complete.js\\\"));\\nvar _AsYouTypeFormatterPatternMatcher = _interopRequireDefault(require(\\\"./AsYouTypeFormatter.PatternMatcher.js\\\"));\\nvar _parseDigits = _interopRequireDefault(require(\\\"./helpers/parseDigits.js\\\"));\\nvar _formatNationalNumberUsingFormat = require(\\\"./helpers/formatNationalNumberUsingFormat.js\\\");\\nvar _constants = require(\\\"./constants.js\\\");\\nvar _applyInternationalSeparatorStyle = _interopRequireDefault(require(\\\"./helpers/applyInternationalSeparatorStyle.js\\\"));\\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \\\"default\\\": e }; }\\nfunction _interopRequireWildcard(e, t) { if (\\\"function\\\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, \\\"default\\\": e }; if (null === e || \\\"object\\\" != _typeof(e) && \\\"function\\\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \\\"default\\\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\\nfunction _typeof(o) { \\\"@babel/helpers - typeof\\\"; return _typeof = \\\"function\\\" == typeof Symbol && \\\"symbol\\\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \\\"function\\\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \\\"symbol\\\" : typeof o; }, _typeof(o); }\\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \\\"undefined\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\"@@iterator\\\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \\\"number\\\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\\\"string\\\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \\\"Object\\\" === t && r.constructor && (t = r.constructor.name), \\\"Map\\\" === t || \\\"Set\\\" === t ? Array.from(r) : \\\"Arguments\\\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\\\"Cannot call a class as a function\\\"); }\\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \\\"value\\\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \\\"prototype\\\", { writable: !1 }), e; }\\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \\\"string\\\"); return \\\"symbol\\\" == _typeof(i) ? i : i + \\\"\\\"; }\\nfunction _toPrimitive(t, r) { if (\\\"object\\\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \\\"default\\\"); if (\\\"object\\\" != _typeof(i)) return i; throw new TypeError(\\\"@@toPrimitive must return a primitive value.\\\"); } return (\\\"string\\\" === r ? String : Number)(t); }\\n// Used in phone number format template creation.\\n// Could be any digit, I guess.\\nvar DUMMY_DIGIT = '9';\\n// I don't know why is it exactly `15`\\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;\\n// Create a phone number consisting only of the digit 9 that matches the\\n// `number_pattern` by applying the pattern to the \\\"longest phone number\\\" string.\\nvar LONGEST_DUMMY_PHONE_NUMBER = (0, _AsYouTypeFormatterUtil.repeat)(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);\\n\\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\\n// us that we should separate the national prefix from the number when formatting.\\nvar NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;\\n\\n// Deprecated: Google has removed some formatting pattern related code from their repo.\\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\\n// \\\"We no longer have numbers in formatting matching patterns, only \\\\d.\\\"\\n// Because this library supports generating custom metadata\\n// some users may still be using old metadata so the relevant\\n// code seems to stay until some next major version update.\\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true;\\n\\n// A pattern that is used to match character classes in regular expressions.\\n// An example of a character class is \\\"[1-4]\\\".\\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\\n  return /\\\\[([^\\\\[\\\\]])*\\\\]/g;\\n};\\n\\n// Any digit in a regular expression that actually denotes a digit. For\\n// example, in the regular expression \\\"80[0-2]\\\\d{6,10}\\\", the first 2 digits\\n// (8 and 0) are standalone digits, but the rest are not.\\n// Two look-aheads are needed because the number following \\\\\\\\d could be a\\n// two-digit number, since the phone number can be as long as 15 digits.\\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\\n  return /\\\\d(?=[^,}][^,}])/g;\\n};\\n\\n// A regular expression that is used to determine if a `format` is\\n// suitable to be used in the \\\"as you type formatter\\\".\\n// A `format` is suitable when the resulting formatted number has\\n// the same digits as the user has entered.\\n//\\n// In the simplest case, that would mean that the format\\n// doesn't add any additional digits when formatting a number.\\n// Google says that it also shouldn't add \\\"star\\\" (`*`) characters,\\n// like it does in some Israeli formats.\\n// Such basic format would only contain \\\"valid punctuation\\\"\\n// and \\\"captured group\\\" identifiers ($1, $2, etc).\\n//\\n// An example of a format that adds additional digits:\\n//\\n// Country: `AR` (Argentina).\\n// Format:\\n// {\\n//    \\\"pattern\\\": \\\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\\\",\\n//    \\\"leading_digits_patterns\\\": [\\\"91\\\"],\\n//    \\\"national_prefix_formatting_rule\\\": \\\"0$1\\\",\\n//    \\\"format\\\": \\\"$2 15-$3-$4\\\",\\n//    \\\"international_format\\\": \\\"$1 $2 $3-$4\\\"\\n// }\\n//\\n// In the format above, the `format` adds `15` to the digits when formatting a number.\\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\\n// has previously removed `15` from a national number, so re-adding `15` in `format`\\n// doesn't actually result in any extra digits added to user's input.\\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\\n// it simply filters out all `format`s that contain anything but \\\"captured group\\\" ids.\\n//\\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\\n// `libphonenumber` code.\\n//\\nvar NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + _constants.VALID_PUNCTUATION + ']*' +\\n// Google developers say:\\n// \\\"We require that the first matching group is present in the\\n//  output pattern to ensure no data is lost while formatting.\\\"\\n'\\\\\\\\$1' + '[' + _constants.VALID_PUNCTUATION + ']*' + '(\\\\\\\\$\\\\\\\\d[' + _constants.VALID_PUNCTUATION + ']*)*' + '$');\\n\\n// This is the minimum length of the leading digits of a phone number\\n// to guarantee the first \\\"leading digits pattern\\\" for a phone number format\\n// to be preemptive.\\nvar MIN_LEADING_DIGITS_LENGTH = 3;\\nvar AsYouTypeFormatter = exports[\\\"default\\\"] = /*#__PURE__*/function () {\\n  function AsYouTypeFormatter(_ref) {\\n    var state = _ref.state,\\n      metadata = _ref.metadata;\\n    _classCallCheck(this, AsYouTypeFormatter);\\n    this.metadata = metadata;\\n    this.resetFormat();\\n  }\\n  return _createClass(AsYouTypeFormatter, [{\\n    key: \\\"resetFormat\\\",\\n    value: function resetFormat() {\\n      this.chosenFormat = undefined;\\n      this.template = undefined;\\n      this.nationalNumberTemplate = undefined;\\n      this.populatedNationalNumberTemplate = undefined;\\n      this.populatedNationalNumberTemplatePosition = -1;\\n    }\\n  }, {\\n    key: \\\"reset\\\",\\n    value: function reset(numberingPlan, state) {\\n      this.resetFormat();\\n      if (numberingPlan) {\\n        this.isNANP = numberingPlan.callingCode() === '1';\\n        this.matchingFormats = numberingPlan.formats();\\n        if (state.nationalSignificantNumber) {\\n          this.narrowDownMatchingFormats(state);\\n        }\\n      } else {\\n        this.isNANP = undefined;\\n        this.matchingFormats = [];\\n      }\\n    }\\n\\n    /**\\r\\n     * Formats an updated phone number.\\r\\n     * @param  {string} nextDigits \\u2014 Additional phone number digits.\\r\\n     * @param  {object} state \\u2014\\u00a0`AsYouType` state.\\r\\n     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\\r\\n     */\\n  }, {\\n    key: \\\"format\\\",\\n    value: function format(nextDigits, state) {\\n      var _this = this;\\n      // See if the phone number digits can be formatted as a complete phone number.\\n      // If not, use the results from `formatNationalNumberWithNextDigits()`,\\n      // which formats based on the chosen formatting pattern.\\n      //\\n      // Attempting to format complete phone number first is how it's done\\n      // in Google's `libphonenumber`, so this library just follows it.\\n      // Google's `libphonenumber` code doesn't explain in detail why does it\\n      // attempt to format digits as a complete phone number\\n      // instead of just going with a previoulsy (or newly) chosen `format`:\\n      //\\n      // \\\"Checks to see if there is an exact pattern match for these digits.\\n      //  If so, we should use this instead of any other formatting template\\n      //  whose leadingDigitsPattern also matches the input.\\\"\\n      //\\n      if ((0, _AsYouTypeFormatterComplete.canFormatCompleteNumber)(state.nationalSignificantNumber, state.country, this.metadata)) {\\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\\n          var _format = _step.value;\\n          var formattedCompleteNumber = (0, _AsYouTypeFormatterComplete[\\\"default\\\"])(state, _format, {\\n            metadata: this.metadata,\\n            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {\\n              return _this.shouldTryNationalPrefixFormattingRule(format, {\\n                international: state.international,\\n                nationalPrefix: state.nationalPrefix\\n              });\\n            },\\n            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {\\n              return _this.getSeparatorAfterNationalPrefix(format);\\n            }\\n          });\\n          if (formattedCompleteNumber) {\\n            this.resetFormat();\\n            this.chosenFormat = _format;\\n            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\\\d/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), state);\\n            this.populatedNationalNumberTemplate = formattedCompleteNumber;\\n            // With a new formatting template, the matched position\\n            // using the old template needs to be reset.\\n            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\\n            return formattedCompleteNumber;\\n          }\\n        }\\n      }\\n      // Format the digits as a partial (incomplete) phone number\\n      // using the previously chosen formatting pattern (or a newly chosen one).\\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\\n    }\\n\\n    // Formats the next phone number digits.\\n  }, {\\n    key: \\\"formatNationalNumberWithNextDigits\\\",\\n    value: function formatNationalNumberWithNextDigits(nextDigits, state) {\\n      var previouslyChosenFormat = this.chosenFormat;\\n\\n      // Choose a format from the list of matching ones.\\n      var newlyChosenFormat = this.chooseFormat(state);\\n      if (newlyChosenFormat) {\\n        if (newlyChosenFormat === previouslyChosenFormat) {\\n          // If it can format the next (current) digits\\n          // using the previously chosen phone number format\\n          // then return the updated formatted number.\\n          return this.formatNextNationalNumberDigits(nextDigits);\\n        } else {\\n          // If a more appropriate phone number format\\n          // has been chosen for these \\\"leading digits\\\",\\n          // then re-format the national phone number part\\n          // using the newly selected format.\\n          return this.formatNextNationalNumberDigits(state.getNationalDigits());\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"narrowDownMatchingFormats\\\",\\n    value: function narrowDownMatchingFormats(_ref2) {\\n      var _this2 = this;\\n      var nationalSignificantNumber = _ref2.nationalSignificantNumber,\\n        nationalPrefix = _ref2.nationalPrefix,\\n        international = _ref2.international;\\n      var leadingDigits = nationalSignificantNumber;\\n\\n      // \\\"leading digits\\\" pattern list starts with a\\n      // \\\"leading digits\\\" pattern fitting a maximum of 3 leading digits.\\n      // So, after a user inputs 3 digits of a national (significant) phone number\\n      // this national (significant) number can already be formatted.\\n      // The next \\\"leading digits\\\" pattern is for 4 leading digits max,\\n      // and the \\\"leading digits\\\" pattern after it is for 5 leading digits max, etc.\\n\\n      // This implementation is different from Google's\\n      // in that it searches for a fitting format\\n      // even if the user has entered less than\\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\\n      // Because some leading digit patterns already match for a single first digit.\\n      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;\\n      if (leadingDigitsPatternIndex < 0) {\\n        leadingDigitsPatternIndex = 0;\\n      }\\n      this.matchingFormats = this.matchingFormats.filter(function (format) {\\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\\n      });\\n\\n      // If there was a phone number format chosen\\n      // and it no longer holds given the new leading digits then reset it.\\n      // The test for this `if` condition is marked as:\\n      // \\\"Reset a chosen format when it no longer holds given the new leading digits\\\".\\n      // To construct a valid test case for this one can find a country\\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\\n      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\\n        this.resetFormat();\\n      }\\n    }\\n  }, {\\n    key: \\\"formatSuits\\\",\\n    value: function formatSuits(format, international, nationalPrefix) {\\n      // When a prefix before a national (significant) number is\\n      // simply a national prefix, then it's parsed as `this.nationalPrefix`.\\n      // In more complex cases, a prefix before national (significant) number\\n      // could include a national prefix as well as some \\\"capturing groups\\\",\\n      // and in that case there's no info whether a national prefix has been parsed.\\n      // If national prefix is not used when formatting a phone number\\n      // using this format, but a national prefix has been entered by the user,\\n      // and was extracted, then discard such phone number format.\\n      // In Google's \\\"AsYouType\\\" formatter code, the equivalent would be this part:\\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\\n      if (nationalPrefix && !format.usesNationalPrefix() &&\\n      // !format.domesticCarrierCodeFormattingRule() &&\\n      !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\\n        return false;\\n      }\\n      // If national prefix is mandatory for this phone number format\\n      // and there're no guarantees that a national prefix is present in user input\\n      // then discard this phone number format as not suitable.\\n      // In Google's \\\"AsYouType\\\" formatter code, the equivalent would be this part:\\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\\n      if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\\n        return false;\\n      }\\n      return true;\\n    }\\n  }, {\\n    key: \\\"formatMatches\\\",\\n    value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;\\n\\n      // If this format is not restricted to a certain\\n      // leading digits pattern then it fits.\\n      // The test case could be found by searching for \\\"leadingDigitsPatternsCount === 0\\\".\\n      if (leadingDigitsPatternsCount === 0) {\\n        return true;\\n      }\\n\\n      // Start narrowing down the list of possible formats based on the leading digits.\\n      // (only previously matched formats take part in the narrowing down process)\\n\\n      // `leading_digits_patterns` start with 3 digits min\\n      // and then go up from there one digit at a time.\\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\\n      var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];\\n\\n      // Google imposes a requirement on the leading digits\\n      // to be minimum 3 digits long in order to be eligible\\n      // for checking those with a leading digits pattern.\\n      //\\n      // Since `leading_digits_patterns` start with 3 digits min,\\n      // Google's original `libphonenumber` library only starts\\n      // excluding any non-matching formats only when the\\n      // national number entered so far is at least 3 digits long,\\n      // otherwise format matching would give false negatives.\\n      //\\n      // For example, when the digits entered so far are `2`\\n      // and the leading digits pattern is `21` \\u2013\\n      // it's quite obvious in this case that the format could be the one\\n      // but due to the absence of further digits it would give false negative.\\n      //\\n      // Also, `leading_digits_patterns` doesn't always correspond to a single\\n      // digits count. For example, `60|8` pattern would already match `8`\\n      // but the `60` part would require having at least two leading digits,\\n      // so the whole pattern would require inputting two digits first in order to\\n      // decide on whether it matches the input, even when the input is \\\"80\\\".\\n      //\\n      // This library \\u2014 `libphonenumber-js` \\u2014 allows filtering by `leading_digits_patterns`\\n      // even when there's only 1 or 2 digits of the national (significant) number.\\n      // To do that, it uses a non-strict pattern matcher written specifically for that.\\n      //\\n      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\\n        // Before leading digits < 3 matching was implemented:\\n        // return true\\n        //\\n        // After leading digits < 3 matching was implemented:\\n        try {\\n          return new _AsYouTypeFormatterPatternMatcher[\\\"default\\\"](leadingDigitsPattern).match(leadingDigits, {\\n            allowOverflow: true\\n          }) !== undefined;\\n        } catch (error) /* istanbul ignore next */{\\n          // There's a slight possibility that there could be some undiscovered bug\\n          // in the pattern matcher code. Since the \\\"leading digits < 3 matching\\\"\\n          // feature is not \\\"essential\\\" for operation, it can fall back to the old way\\n          // in case of any issues rather than halting the application's execution.\\n          console.error(error);\\n          return true;\\n        }\\n      }\\n\\n      // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\\n      // available then use the usual regular expression matching.\\n      //\\n      // The whole pattern is wrapped in round brackets (`()`) because\\n      // the pattern can use \\\"or\\\" operator (`|`) at the top level of the pattern.\\n      //\\n      return new RegExp(\\\"^(\\\".concat(leadingDigitsPattern, \\\")\\\")).test(leadingDigits);\\n    }\\n  }, {\\n    key: \\\"getFormatFormat\\\",\\n    value: function getFormatFormat(format, international) {\\n      return international ? format.internationalFormat() : format.format();\\n    }\\n  }, {\\n    key: \\\"chooseFormat\\\",\\n    value: function chooseFormat(state) {\\n      var _this3 = this;\\n      var _loop = function _loop() {\\n          var format = _step2.value;\\n          // If this format is currently being used\\n          // and is still suitable, then stick to it.\\n          if (_this3.chosenFormat === format) {\\n            return 0; // break\\n          }\\n          // Sometimes, a formatting rule inserts additional digits in a phone number,\\n          // and \\\"as you type\\\" formatter can't do that: it should only use the digits\\n          // that the user has input.\\n          //\\n          // For example, in Argentina, there's a format for mobile phone numbers:\\n          //\\n          // {\\n          //    \\\"pattern\\\": \\\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\\\",\\n          //    \\\"leading_digits_patterns\\\": [\\\"91\\\"],\\n          //    \\\"national_prefix_formatting_rule\\\": \\\"0$1\\\",\\n          //    \\\"format\\\": \\\"$2 15-$3-$4\\\",\\n          //    \\\"international_format\\\": \\\"$1 $2 $3-$4\\\"\\n          // }\\n          //\\n          // In that format, `international_format` is used instead of `format`\\n          // because `format` inserts `15` in the formatted number,\\n          // and `AsYouType` formatter should only use the digits\\n          // the user has actually input, without adding any extra digits.\\n          // In this case, it wouldn't make a difference, because the `15`\\n          // is first stripped when applying `national_prefix_for_parsing`\\n          // and then re-added when using `format`, so in reality it doesn't\\n          // add any new digits to the number, but to detect that, the code\\n          // would have to be more complex: it would have to try formatting\\n          // the digits using the format and then see if any digits have\\n          // actually been added or removed, and then, every time a new digit\\n          // is input, it should re-check whether the chosen format doesn't\\n          // alter the digits.\\n          //\\n          // Google's code doesn't go that far, and so does this library:\\n          // it simply requires that a `format` doesn't add any additonal\\n          // digits to user's input.\\n          //\\n          // Also, people in general should move from inputting phone numbers\\n          // in national format (possibly with national prefixes)\\n          // and use international phone number format instead:\\n          // it's a logical thing in the modern age of mobile phones,\\n          // globalization and the internet.\\n          //\\n          /* istanbul ignore if */\\n          if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\\n            return 1; // continue\\n          }\\n          if (!_this3.createTemplateForFormat(format, state)) {\\n            // Remove the format if it can't generate a template.\\n            _this3.matchingFormats = _this3.matchingFormats.filter(function (_) {\\n              return _ !== format;\\n            });\\n            return 1; // continue\\n          }\\n          _this3.chosenFormat = format;\\n          return 0; // break\\n        },\\n        _ret;\\n      // When there are multiple available formats, the formatter uses the first\\n      // format where a formatting template could be created.\\n      //\\n      // For some weird reason, `istanbul` says \\\"else path not taken\\\"\\n      // for the `for of` line below. Supposedly that means that\\n      // the loop doesn't ever go over the last element in the list.\\n      // That's true because there always is `this.chosenFormat`\\n      // when `this.matchingFormats` is non-empty.\\n      // And, for some weird reason, it doesn't think that the case\\n      // with empty `this.matchingFormats` qualifies for a valid \\\"else\\\" path.\\n      // So simply muting this `istanbul` warning.\\n      // It doesn't skip the contents of the `for of` loop,\\n      // it just skips the `for of` line.\\n      //\\n      /* istanbul ignore next */\\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;) {\\n        _ret = _loop();\\n        if (_ret === 0) break;\\n        if (_ret === 1) continue;\\n      }\\n      if (!this.chosenFormat) {\\n        // No format matches the national (significant) phone number.\\n        this.resetFormat();\\n      }\\n      return this.chosenFormat;\\n    }\\n  }, {\\n    key: \\\"createTemplateForFormat\\\",\\n    value: function createTemplateForFormat(format, state) {\\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\\n      // (20|3)\\\\d{4}. In those cases we quickly return.\\n      // (Though there's no such format in current metadata)\\n      /* istanbul ignore if */\\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\\n        return;\\n      }\\n      // Get formatting template for this phone number format\\n      var template = this.getTemplateForFormat(format, state);\\n      // If the national number entered is too long\\n      // for any phone number format, then abort.\\n      if (template) {\\n        this.setNationalNumberTemplate(template, state);\\n        return true;\\n      }\\n    }\\n  }, {\\n    key: \\\"getSeparatorAfterNationalPrefix\\\",\\n    value: function getSeparatorAfterNationalPrefix(format) {\\n      // `US` metadata doesn't have a `national_prefix_formatting_rule`,\\n      // so the `if` condition below doesn't apply to `US`,\\n      // but in reality there shoudl be a separator\\n      // between a national prefix and a national (significant) number.\\n      // So `US` national prefix separator is a \\\"special\\\" \\\"hardcoded\\\" case.\\n      if (this.isNANP) {\\n        return ' ';\\n      }\\n      // If a `format` has a `national_prefix_formatting_rule`\\n      // and that rule has a separator after a national prefix,\\n      // then it means that there should be a separator\\n      // between a national prefix and a national (significant) number.\\n      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\\n        return ' ';\\n      }\\n      // At this point, there seems to be no clear evidence that\\n      // there should be a separator between a national prefix\\n      // and a national (significant) number. So don't insert one.\\n      return '';\\n    }\\n  }, {\\n    key: \\\"getInternationalPrefixBeforeCountryCallingCode\\\",\\n    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {\\n      var IDDPrefix = _ref3.IDDPrefix,\\n        missingPlus = _ref3.missingPlus;\\n      if (IDDPrefix) {\\n        return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';\\n      }\\n      if (missingPlus) {\\n        return '';\\n      }\\n      return '+';\\n    }\\n  }, {\\n    key: \\\"getTemplate\\\",\\n    value: function getTemplate(state) {\\n      if (!this.template) {\\n        return;\\n      }\\n      // `this.template` holds the template for a \\\"complete\\\" phone number.\\n      // The currently entered phone number is most likely not \\\"complete\\\",\\n      // so trim all non-populated digits.\\n      var index = -1;\\n      var i = 0;\\n      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {\\n        spacing: false\\n      }) : '';\\n      while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\\n        index = this.template.indexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, index + 1);\\n        i++;\\n      }\\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.template, index + 1);\\n    }\\n  }, {\\n    key: \\\"setNationalNumberTemplate\\\",\\n    value: function setNationalNumberTemplate(template, state) {\\n      this.nationalNumberTemplate = template;\\n      this.populatedNationalNumberTemplate = template;\\n      // With a new formatting template, the matched position\\n      // using the old template needs to be reset.\\n      this.populatedNationalNumberTemplatePosition = -1;\\n      // For convenience, the public `.template` property\\n      // contains the whole international number\\n      // if the phone number being input is international:\\n      // 'x' for the '+' sign, 'x'es for the country phone code,\\n      // a spacebar and then the template for the formatted national number.\\n      if (state.international) {\\n        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\\\d\\\\+]/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER) + (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, state.callingCode.length) + ' ' + template;\\n      } else {\\n        this.template = template;\\n      }\\n    }\\n\\n    /**\\r\\n     * Generates formatting template for a national phone number,\\r\\n     * optionally containing a national prefix, for a format.\\r\\n     * @param  {Format} format\\r\\n     * @param  {string} nationalPrefix\\r\\n     * @return {string}\\r\\n     */\\n  }, {\\n    key: \\\"getTemplateForFormat\\\",\\n    value: function getTemplateForFormat(format, _ref4) {\\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber,\\n        international = _ref4.international,\\n        nationalPrefix = _ref4.nationalPrefix,\\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _ref4.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\\n      var pattern = format.pattern();\\n\\n      /* istanbul ignore else */\\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\\n        pattern = pattern\\n        // Replace anything in the form of [..] with \\\\d\\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\\\\\d')\\n        // Replace any standalone digit (not the one in `{}`) with \\\\d\\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\\\\\d');\\n      }\\n\\n      // Generate a dummy national number (consisting of `9`s)\\n      // that fits this format's `pattern`.\\n      //\\n      // This match will always succeed,\\n      // because the \\\"longest dummy phone number\\\"\\n      // has enough length to accomodate any possible\\n      // national phone number format pattern.\\n      //\\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];\\n\\n      // If the national number entered is too long\\n      // for any phone number format, then abort.\\n      if (nationalSignificantNumber.length > digits.length) {\\n        return;\\n      }\\n\\n      // Get a formatting template which can be used to efficiently format\\n      // a partial number where digits are added one by one.\\n\\n      // Below `strictPattern` is used for the\\n      // regular expression (with `^` and `$`).\\n      // This wasn't originally in Google's `libphonenumber`\\n      // and I guess they don't really need it\\n      // because they're not using \\\"templates\\\" to format phone numbers\\n      // but I added `strictPattern` after encountering\\n      // South Korean phone number formatting bug.\\n      //\\n      // Non-strict regular expression bug demonstration:\\n      //\\n      // this.nationalSignificantNumber : `111111111` (9 digits)\\n      //\\n      // pattern : (\\\\d{2})(\\\\d{3,4})(\\\\d{4})\\n      // format : `$1 $2 $3`\\n      // digits : `9999999999` (10 digits)\\n      //\\n      // '9999999999'.replace(new RegExp(/(\\\\d{2})(\\\\d{3,4})(\\\\d{4})/g), '$1 $2 $3') = \\\"99 9999 9999\\\"\\n      //\\n      // template : xx xxxx xxxx\\n      //\\n      // But the correct template in this case is `xx xxx xxxx`.\\n      // The template was generated incorrectly because of the\\n      // `{3,4}` variability in the `pattern`.\\n      //\\n      // The fix is, if `this.nationalSignificantNumber` has already sufficient length\\n      // to satisfy the `pattern` completely then `this.nationalSignificantNumber`\\n      // is used instead of `digits`.\\n\\n      var strictPattern = new RegExp('^' + pattern + '$');\\n      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\\\d/g, DUMMY_DIGIT);\\n\\n      // If `this.nationalSignificantNumber` has already sufficient length\\n      // to satisfy the `pattern` completely then use it\\n      // instead of `digits`.\\n      if (strictPattern.test(nationalNumberDummyDigits)) {\\n        digits = nationalNumberDummyDigits;\\n      }\\n      var numberFormat = this.getFormatFormat(format, international);\\n      var nationalPrefixIncludedInTemplate;\\n\\n      // If a user did input a national prefix (and that's guaranteed),\\n      // and if a `format` does have a national prefix formatting rule,\\n      // then see if that national prefix formatting rule\\n      // prepends exactly the same national prefix the user has input.\\n      // If that's the case, then use the `format` with the national prefix formatting rule.\\n      // Otherwise, use  the `format` without the national prefix formatting rule,\\n      // and prepend a national prefix manually to it.\\n      if (this.shouldTryNationalPrefixFormattingRule(format, {\\n        international: international,\\n        nationalPrefix: nationalPrefix\\n      })) {\\n        var numberFormatWithNationalPrefix = numberFormat.replace(_formatNationalNumberUsingFormat.FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());\\n        // If `national_prefix_formatting_rule` of a `format` simply prepends\\n        // national prefix at the start of a national (significant) number,\\n        // then such formatting can be used with `AsYouType` formatter.\\n        // There seems to be no `else` case: everywhere in metadata,\\n        // national prefix formatting rule is national prefix + $1,\\n        // or `($1)`, in which case such format isn't even considered\\n        // when the user has input a national prefix.\\n        /* istanbul ignore else */\\n        if ((0, _parseDigits[\\\"default\\\"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + (0, _parseDigits[\\\"default\\\"])('$1')) {\\n          numberFormat = numberFormatWithNationalPrefix;\\n          nationalPrefixIncludedInTemplate = true;\\n          // Replace all digits of the national prefix in the formatting template\\n          // with `DIGIT_PLACEHOLDER`s.\\n          if (nationalPrefix) {\\n            var i = nationalPrefix.length;\\n            while (i > 0) {\\n              numberFormat = numberFormat.replace(/\\\\d/, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\\n              i--;\\n            }\\n          }\\n        }\\n      }\\n\\n      // Generate formatting template for this phone number format.\\n      var template = digits\\n      // Format the dummy phone number according to the format.\\n      .replace(new RegExp(pattern), numberFormat)\\n      // Replace each dummy digit with a DIGIT_PLACEHOLDER.\\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\\n\\n      // If a prefix of a national (significant) number is not as simple\\n      // as just a basic national prefix, then just prepend such prefix\\n      // before the national (significant) number, optionally spacing\\n      // the two with a whitespace.\\n      if (!nationalPrefixIncludedInTemplate) {\\n        if (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\\n          // Prepend the prefix to the template manually.\\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) + ' ' + template;\\n        } else if (nationalPrefix) {\\n          // Prepend national prefix to the template manually.\\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;\\n        }\\n      }\\n      if (international) {\\n        template = (0, _applyInternationalSeparatorStyle[\\\"default\\\"])(template);\\n      }\\n      return template;\\n    }\\n  }, {\\n    key: \\\"formatNextNationalNumberDigits\\\",\\n    value: function formatNextNationalNumberDigits(digits) {\\n      var result = (0, _AsYouTypeFormatterUtil.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);\\n      if (!result) {\\n        // Reset the format.\\n        this.resetFormat();\\n        return;\\n      }\\n      this.populatedNationalNumberTemplate = result[0];\\n      this.populatedNationalNumberTemplatePosition = result[1];\\n\\n      // Return the formatted phone number so far.\\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);\\n\\n      // The old way which was good for `input-format` but is not so good\\n      // for `react-phone-number-input`'s default input (`InputBasic`).\\n      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\\n      // \\t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\\n    }\\n  }, {\\n    key: \\\"shouldTryNationalPrefixFormattingRule\\\",\\n    value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {\\n      var international = _ref5.international,\\n        nationalPrefix = _ref5.nationalPrefix;\\n      if (format.nationalPrefixFormattingRule()) {\\n        // In some countries, `national_prefix_formatting_rule` is `($1)`,\\n        // so it applies even if the user hasn't input a national prefix.\\n        // `format.usesNationalPrefix()` detects such cases.\\n        var usesNationalPrefix = format.usesNationalPrefix();\\n        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {\\n          return true;\\n        }\\n      }\\n    }\\n  }]);\\n}();\\n//# sourceMappingURL=AsYouTypeFormatter.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"e\",\"__esModule\",\"_interopRequireWildcard\",\"t\",\"WeakMap\",\"r\",\"n\",\"i\",\"f\",\"__proto__\",\"_typeof\",\"o\",\"has\",\"get\",\"set\",\"_t\",\"hasOwnProperty\",\"call\",\"Object\",\"defineProperty\",\"getOwnPropertyDescriptor\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_createForOfIteratorHelperLoose\",\"next\",\"bind\",\"Array\",\"isArray\",\"_unsupportedIterableToArray\",\"length\",\"done\",\"value\",\"TypeError\",\"a\",\"_arrayLikeToArray\",\"toString\",\"slice\",\"name\",\"from\",\"test\",\"_defineProperties\",\"enumerable\",\"configurable\",\"writable\",\"key\",\"toPrimitive\",\"String\",\"_createClass\",\"_AsYouTypeFormatterUtil\",\"DIGIT_PLACEHOLDER\",\"_AsYouTypeFormatterComplete\",\"_AsYouTypeFormatterPatternMatcher\",\"_parseDigits\",\"_formatNationalNumberUsingFormat\",\"_constants\",\"_applyInternationalSeparatorStyle\",\"LONGEST_DUMMY_PHONE_NUMBER\",\"repeat\",\"DUMMY_DIGIT\",\"LONGEST_NATIONAL_PHONE_NUMBER_LENGTH\",\"NATIONAL_PREFIX_SEPARATORS_PATTERN\",\"NON_ALTERING_FORMAT_REG_EXP\",\"RegExp\",\"VALID_PUNCTUATION\",\"AsYouTypeFormatter\",\"_ref\",\"metadata\",\"resetFormat\",\"populatedNationalNumberTemplate\",\"nationalNumberTemplate\",\"template\",\"chosenFormat\",\"undefined\",\"populatedNationalNumberTemplatePosition\",\"reset\",\"numberingPlan\",\"state\",\"isNANP\",\"callingCode\",\"matchingFormats\",\"formats\",\"nationalSignificantNumber\",\"narrowDownMatchingFormats\",\"format\",\"nextDigits\",\"_this\",\"canFormatCompleteNumber\",\"country\",\"_iterator\",\"_step\",\"_format\",\"formattedCompleteNumber\",\"shouldTryNationalPrefixFormattingRule\",\"international\",\"nationalPrefix\",\"getSeparatorAfterNationalPrefix\",\"setNationalNumberTemplate\",\"replace\",\"lastIndexOf\",\"formatNationalNumberWithNextDigits\",\"previouslyChosenFormat\",\"newlyChosenFormat\",\"chooseFormat\",\"formatNextNationalNumberDigits\",\"getNationalDigits\",\"_ref2\",\"_this2\",\"leadingDigits\",\"leadingDigitsPatternIndex\",\"MIN_LEADING_DIGITS_LENGTH\",\"filter\",\"formatSuits\",\"formatMatches\",\"indexOf\",\"usesNationalPrefix\",\"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\"nationalPrefixIsMandatoryWhenFormattingInNationalFormat\",\"leadingDigitsPatternsCount\",\"leadingDigitsPatterns\",\"Math\",\"min\",\"leadingDigitsPattern\",\"match\",\"allowOverflow\",\"error\",\"console\",\"concat\",\"getFormatFormat\",\"internationalFormat\",\"_this3\",\"_loop\",\"_step2\",\"createTemplateForFormat\",\"_\",\"_ret\",\"_iterator2\",\"pattern\",\"getTemplateForFormat\",\"nationalPrefixFormattingRule\",\"getInternationalPrefixBeforeCountryCallingCode\",\"_ref3\",\"options\",\"IDDPrefix\",\"spacing\",\"missingPlus\",\"getTemplate\",\"index\",\"internationalPrefix\",\"getDigitsWithoutInternationalPrefix\",\"cutAndStripNonPairedParens\",\"_ref4\",\"prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\",\"digits\",\"strictPattern\",\"nationalNumberDummyDigits\",\"numberFormat\",\"numberFormatWithNationalPrefix\",\"FIRST_GROUP_PATTERN\",\"nationalPrefixIncludedInTemplate\",\"result\",\"populateTemplateWithDigits\",\"_ref5\"]\n}\n"]
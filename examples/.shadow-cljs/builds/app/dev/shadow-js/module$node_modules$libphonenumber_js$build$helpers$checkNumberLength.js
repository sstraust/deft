["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/libphonenumber-js/build/helpers/checkNumberLength.js"],"~:js","shadow$provide.module$node_modules$libphonenumber_js$build$helpers$checkNumberLength = function(global, require, module, exports) {\n  function _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\"default\":e};\n  }\n  function checkNumberLengthForType(nationalNumber, country, type, metadata) {\n    country && (metadata = new _metadata[\"default\"](metadata.metadata), metadata.selectNumberingPlan(country));\n    var type_info = metadata.type(type), possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();\n    if (!possible_lengths) {\n      return \"IS_POSSIBLE\";\n    }\n    if (\"FIXED_LINE_OR_MOBILE\" === type) {\n      if (!metadata.type(\"FIXED_LINE\")) {\n        return checkNumberLengthForType(nationalNumber, country, \"MOBILE\", metadata);\n      }\n      (country = metadata.type(\"MOBILE\")) && (possible_lengths = (0,_mergeArrays[\"default\"])(possible_lengths, country.possibleLengths()));\n    } else if (type && !type_info) {\n      return \"INVALID_LENGTH\";\n    }\n    nationalNumber = nationalNumber.length;\n    country = possible_lengths[0];\n    return country === nationalNumber ? \"IS_POSSIBLE\" : country > nationalNumber ? \"TOO_SHORT\" : possible_lengths[possible_lengths.length - 1] < nationalNumber ? \"TOO_LONG\" : 0 <= possible_lengths.indexOf(nationalNumber, 1) ? \"IS_POSSIBLE\" : \"INVALID_LENGTH\";\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.checkNumberLengthForType = checkNumberLengthForType;\n  exports[\"default\"] = function(nationalNumber, country, metadata) {\n    return checkNumberLengthForType(nationalNumber, country, void 0, metadata);\n  };\n  var _metadata = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$metadata\")), _mergeArrays = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$mergeArrays\"));\n};\n","~:source","shadow$provide[\"module$node_modules$libphonenumber_js$build$helpers$checkNumberLength\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkNumberLengthForType = checkNumberLengthForType;\nexports[\"default\"] = checkNumberLength;\nvar _metadata = _interopRequireDefault(require(\"../metadata.js\"));\nvar _mergeArrays = _interopRequireDefault(require(\"./mergeArrays.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction checkNumberLength(nationalNumber, country, metadata) {\n  return checkNumberLengthForType(nationalNumber, country, undefined, metadata);\n}\n\n// Checks whether a number is possible for a certain `country` based on the number length.\n//\n// This function is not supported by metadata generated with ancient versions of\n// `libphonenumber-js` (before version `1.0.18`) which didn't include \"possible lengths\".\n//\n// There was also a known issue with `checkNumberLength()` function:\n// if a number is possible only in a certain `country` among several `countries`\n// that share the same \"country calling code\", that function would check\n// the possibility of the phone number only in the \"main\" `country` for the \"country calling code\"\n// and would not check if it's actually be possible in the speciifc `country`.\n//\n// For example, \"+1310xxxx\" numbers are valid in Canada.\n// However, they are not possible in the US due to being too short.\n// Since Canada and the US share the same country calling code — \"+1\" —\n// `checkNumberLength()` function used to return not \"IS_POSSIBLE\" for \"+1310xxxx\" numbers.\n//\n// In such cases, when using \"/max\" metadata, `isValid()` could output `true`\n// but at the same time `isPossible()` could output `false`, which was contradictory.\n//\n// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.\n//\n// The solution suggested by Google was implemented: an optional `country` argument\n// was added to `checkNumberLength()` function. If present, that `country` will be used\n// to check phone number length for that specific `country` rather than the \"main\" country\n// for the shared \"country calling code\".\n//\nfunction checkNumberLengthForType(nationalNumber, country, type, metadata) {\n  // If the exact `country` is specified, it's no necessarily already selected in `metadata`.\n  // Most likely, in cases when there're multiple countries corresponding to the same\n  // \"country calling code\", the \"main\" country for that \"country calling code\" will be selected.\n  if (country) {\n    metadata = new _metadata[\"default\"](metadata.metadata);\n    metadata.selectNumberingPlan(country);\n  }\n  var type_info = metadata.type(type);\n\n  // There should always be \"<possiblePengths/>\" set for every type element.\n  // This is declared in the XML schema.\n  // For size efficiency, where a sub-description (e.g. fixed-line)\n  // has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n  // so we fall back to the \"general description\". Where no numbers of the type\n  // exist at all, there is one possible length (-1) which is guaranteed\n  // not to match the length of any real phone number.\n  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();\n  // let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n\n  // Metadata before version `1.0.18` didn't contain `possible_lengths`.\n  if (!possible_lengths) {\n    return 'IS_POSSIBLE';\n  }\n  if (type === 'FIXED_LINE_OR_MOBILE') {\n    // No such country in metadata.\n    /* istanbul ignore next */\n    if (!metadata.type('FIXED_LINE')) {\n      // The rare case has been encountered where no fixedLine data is available\n      // (true for some non-geographic entities), so we just check mobile.\n      return checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata);\n    }\n    var mobile_type = metadata.type('MOBILE');\n    if (mobile_type) {\n      // Merge the mobile data in if there was any. \"Concat\" creates a new\n      // array, it doesn't edit possible_lengths in place, so we don't need a copy.\n      // Note that when adding the possible lengths from mobile, we have\n      // to again check they aren't empty since if they are this indicates\n      // they are the same as the general desc and should be obtained from there.\n      possible_lengths = (0, _mergeArrays[\"default\"])(possible_lengths, mobile_type.possibleLengths());\n      // The current list is sorted; we need to merge in the new list and\n      // re-sort (duplicates are okay). Sorting isn't so expensive because\n      // the lists are very small.\n\n      // if (local_lengths) {\n      // \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\n      // } else {\n      // \tlocal_lengths = mobile_type.possibleLengthsLocal()\n      // }\n    }\n  }\n  // If the type doesn't exist then return 'INVALID_LENGTH'.\n  else if (type && !type_info) {\n    return 'INVALID_LENGTH';\n  }\n  var actual_length = nationalNumber.length;\n\n  // In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\n  // // This is safe because there is never an overlap beween the possible lengths\n  // // and the local-only lengths; this is checked at build time.\n  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\n  // {\n  // \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n  // }\n\n  var minimum_length = possible_lengths[0];\n  if (minimum_length === actual_length) {\n    return 'IS_POSSIBLE';\n  }\n  if (minimum_length > actual_length) {\n    return 'TOO_SHORT';\n  }\n  if (possible_lengths[possible_lengths.length - 1] < actual_length) {\n    return 'TOO_LONG';\n  }\n\n  // We skip the first element since we've already checked it.\n  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';\n}\n//# sourceMappingURL=checkNumberLength.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$libphonenumber_js$build$helpers$mergeArrays","~$module$node_modules$libphonenumber_js$build$metadata","~$shadow.js"]],"~:properties",["^5",["__esModule","value","checkNumberLengthForType"]],"~:compiled-at",1760720685895,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$libphonenumber_js$build$helpers$checkNumberLength.js\",\n\"lineCount\":30,\n\"mappings\":\"AAAAA,cAAA,CAAA,qEAAA,GAA0F,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAUlIC,UAASA,uBAAsB,CAACC,CAAD,CAAI;AAAE,WAAOA,CAAA,IAAKA,CAAEC,CAAAA,UAAP,GAAoBD,CAApB,GAAwB,CAAE,UAAWA,CAAb,CAA/B;AAAF;AA+BnCE,UAASA,yBAAwB,CAACC,cAAD,EAAiBC,OAAjB,EAA0BC,IAA1B,EAAgCC,QAAhC,CAA0C;AAIrEF,WAAJ,KACEE,QACA,GADW,IAAIC,SAAA,CAAU,SAAV,CAAJ,CAAyBD,QAASA,CAAAA,QAAlC,CACX,EAAAA,QAASE,CAAAA,mBAAT,CAA6BJ,OAA7B,CAFF;AAIA,QAAIK,YAAYH,QAASD,CAAAA,IAAT,CAAcA,IAAd,CAAhB,EASIK,mBAAmBD,SAAnBC,IAAgCD,SAAUE,CAAAA,eAAV,EAAhCD,IAA+DJ,QAASK,CAAAA,eAAT,EATnE;AAaA,QAAI,CAACD,gBAAL;AACE,aAAO,aAAP;AADF;AAGA,QAAa,sBAAb,KAAIL,IAAJ,CAAqC;AAGnC,UAAI,CAACC,QAASD,CAAAA,IAAT,CAAc,YAAd,CAAL;AAGE,eAAOH,wBAAA,CAAyBC,cAAzB,EAAyCC,OAAzC,EAAkD,QAAlD,EAA4DE,QAA5D,CAAP;AAHF;AAMA,OADIM,OACJ,GADkBN,QAASD,CAAAA,IAAT,CAAc,QAAd,CAClB,MAMEK,gBANF,GAMqB,GAAIG,YAAA,CAAa,SAAb,CAAJ,EAA6BH,gBAA7B,EAA+CE,OAAYD,CAAAA,eAAZ,EAA/C,CANrB;AATmC,KAArC,KA4BK,KAAIN,IAAJ,IAAY,CAACI,SAAb;AACH,aAAO,gBAAP;AADG;AAGDK,kBAAAA,GAAgBX,cAAeY,CAAAA,MAA/BD;AAUAE,WAAAA,GAAiBN,gBAAA,CAAiB,CAAjB,CAAjBM;AACJ,WAAIA,OAAJ,KAAuBF,cAAvB,GACS,aADT,GAGIE,OAAJ,GAAqBF,cAArB,GACS,WADT,GAGIJ,gBAAA,CAAiBA,gBAAiBK,CAAAA,MAAlC,GAA2C,CAA3C,CAAJ,GAAoDD,cAApD,GACS,UADT,GAKqD,CAA9C,IAAAJ,gBAAiBO,CAAAA,OAAjB,CAAyBH,cAAzB,EAAwC,CAAxC,CAAA,GAAkD,aAAlD,GAAkE,gBAXzE;AAlEyE;AAtC3EI,QAAOC,CAAAA,cAAP,CAAsBrB,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CsB,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAtB,SAAQI,CAAAA,wBAAR,GAAmCA,wBAAnC;AACAJ,SAAA,CAAQ,SAAR,CAAA,GAIAuB,QAA0B,CAAClB,cAAD,EAAiBC,OAAjB,EAA0BE,QAA1B,CAAoC;AAC5D,WAAOJ,wBAAA,CAAyBC,cAAzB,EAAyCC,OAAzC,EAAkDkB,IAAAA,EAAlD,EAA6DhB,QAA7D,CAAP;AAD4D,GAJ9D;AACA,MAAIC,YAAYR,sBAAA,CAAuBH,OAAA,CAAQ,sDAAR,CAAvB,CAAhB,EACIiB,eAAed,sBAAA,CAAuBH,OAAA,CAAQ,iEAAR,CAAvB,CADnB;AARkI,CAAlI;;\",\n\"sources\":[\"node_modules/libphonenumber-js/build/helpers/checkNumberLength.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$libphonenumber_js$build$helpers$checkNumberLength\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.checkNumberLengthForType = checkNumberLengthForType;\\nexports[\\\"default\\\"] = checkNumberLength;\\nvar _metadata = _interopRequireDefault(require(\\\"../metadata.js\\\"));\\nvar _mergeArrays = _interopRequireDefault(require(\\\"./mergeArrays.js\\\"));\\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \\\"default\\\": e }; }\\nfunction checkNumberLength(nationalNumber, country, metadata) {\\n  return checkNumberLengthForType(nationalNumber, country, undefined, metadata);\\n}\\n\\n// Checks whether a number is possible for a certain `country` based on the number length.\\n//\\n// This function is not supported by metadata generated with ancient versions of\\n// `libphonenumber-js` (before version `1.0.18`) which didn't include \\\"possible lengths\\\".\\n//\\n// There was also a known issue with `checkNumberLength()` function:\\n// if a number is possible only in a certain `country` among several `countries`\\n// that share the same \\\"country calling code\\\", that function would check\\n// the possibility of the phone number only in the \\\"main\\\" `country` for the \\\"country calling code\\\"\\n// and would not check if it's actually be possible in the speciifc `country`.\\n//\\n// For example, \\\"+1310xxxx\\\" numbers are valid in Canada.\\n// However, they are not possible in the US due to being too short.\\n// Since Canada and the US share the same country calling code \\u2014 \\\"+1\\\" \\u2014\\n// `checkNumberLength()` function used to return not \\\"IS_POSSIBLE\\\" for \\\"+1310xxxx\\\" numbers.\\n//\\n// In such cases, when using \\\"/max\\\" metadata, `isValid()` could output `true`\\n// but at the same time `isPossible()` could output `false`, which was contradictory.\\n//\\n// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.\\n//\\n// The solution suggested by Google was implemented: an optional `country` argument\\n// was added to `checkNumberLength()` function. If present, that `country` will be used\\n// to check phone number length for that specific `country` rather than the \\\"main\\\" country\\n// for the shared \\\"country calling code\\\".\\n//\\nfunction checkNumberLengthForType(nationalNumber, country, type, metadata) {\\n  // If the exact `country` is specified, it's no necessarily already selected in `metadata`.\\n  // Most likely, in cases when there're multiple countries corresponding to the same\\n  // \\\"country calling code\\\", the \\\"main\\\" country for that \\\"country calling code\\\" will be selected.\\n  if (country) {\\n    metadata = new _metadata[\\\"default\\\"](metadata.metadata);\\n    metadata.selectNumberingPlan(country);\\n  }\\n  var type_info = metadata.type(type);\\n\\n  // There should always be \\\"<possiblePengths/>\\\" set for every type element.\\n  // This is declared in the XML schema.\\n  // For size efficiency, where a sub-description (e.g. fixed-line)\\n  // has the same \\\"<possiblePengths/>\\\" as the \\\"general description\\\", this is missing,\\n  // so we fall back to the \\\"general description\\\". Where no numbers of the type\\n  // exist at all, there is one possible length (-1) which is guaranteed\\n  // not to match the length of any real phone number.\\n  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();\\n  // let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\\n\\n  // Metadata before version `1.0.18` didn't contain `possible_lengths`.\\n  if (!possible_lengths) {\\n    return 'IS_POSSIBLE';\\n  }\\n  if (type === 'FIXED_LINE_OR_MOBILE') {\\n    // No such country in metadata.\\n    /* istanbul ignore next */\\n    if (!metadata.type('FIXED_LINE')) {\\n      // The rare case has been encountered where no fixedLine data is available\\n      // (true for some non-geographic entities), so we just check mobile.\\n      return checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata);\\n    }\\n    var mobile_type = metadata.type('MOBILE');\\n    if (mobile_type) {\\n      // Merge the mobile data in if there was any. \\\"Concat\\\" creates a new\\n      // array, it doesn't edit possible_lengths in place, so we don't need a copy.\\n      // Note that when adding the possible lengths from mobile, we have\\n      // to again check they aren't empty since if they are this indicates\\n      // they are the same as the general desc and should be obtained from there.\\n      possible_lengths = (0, _mergeArrays[\\\"default\\\"])(possible_lengths, mobile_type.possibleLengths());\\n      // The current list is sorted; we need to merge in the new list and\\n      // re-sort (duplicates are okay). Sorting isn't so expensive because\\n      // the lists are very small.\\n\\n      // if (local_lengths) {\\n      // \\tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\\n      // } else {\\n      // \\tlocal_lengths = mobile_type.possibleLengthsLocal()\\n      // }\\n    }\\n  }\\n  // If the type doesn't exist then return 'INVALID_LENGTH'.\\n  else if (type && !type_info) {\\n    return 'INVALID_LENGTH';\\n  }\\n  var actual_length = nationalNumber.length;\\n\\n  // In `libphonenumber-js` all \\\"local-only\\\" formats are dropped for simplicity.\\n  // // This is safe because there is never an overlap beween the possible lengths\\n  // // and the local-only lengths; this is checked at build time.\\n  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\\n  // {\\n  // \\treturn 'IS_POSSIBLE_LOCAL_ONLY'\\n  // }\\n\\n  var minimum_length = possible_lengths[0];\\n  if (minimum_length === actual_length) {\\n    return 'IS_POSSIBLE';\\n  }\\n  if (minimum_length > actual_length) {\\n    return 'TOO_SHORT';\\n  }\\n  if (possible_lengths[possible_lengths.length - 1] < actual_length) {\\n    return 'TOO_LONG';\\n  }\\n\\n  // We skip the first element since we've already checked it.\\n  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';\\n}\\n//# sourceMappingURL=checkNumberLength.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"e\",\"__esModule\",\"checkNumberLengthForType\",\"nationalNumber\",\"country\",\"type\",\"metadata\",\"_metadata\",\"selectNumberingPlan\",\"type_info\",\"possible_lengths\",\"possibleLengths\",\"mobile_type\",\"_mergeArrays\",\"actual_length\",\"length\",\"minimum_length\",\"indexOf\",\"Object\",\"defineProperty\",\"value\",\"checkNumberLength\",\"undefined\"]\n}\n"]
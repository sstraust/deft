["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/libphonenumber-js/build/findNumbers/Leniency.js"],"~:js","shadow$provide.module$node_modules$libphonenumber_js$build$findNumbers$Leniency = function(global, require, module, exports) {\n  function _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\"default\":e};\n  }\n  function containsOnlyValidXChars(phoneNumber, candidate, metadata) {\n    for (var index = 0; index < candidate.length - 1; index++) {\n      var charAtIndex = candidate.charAt(index);\n      if (\"x\" === charAtIndex || \"X\" === charAtIndex) {\n        if (charAtIndex = candidate.charAt(index + 1), \"x\" === charAtIndex || \"X\" === charAtIndex) {\n          if (index++, \"NSN_MATCH\" !== (0,_matchPhoneNumberStringAgainstPhoneNumber[\"default\"])(candidate.substring(index), phoneNumber, metadata)) {\n            return !1;\n          }\n        } else {\n          if (charAtIndex = (0,_parseDigits[\"default\"])(candidate.substring(index))) {\n            if (phoneNumber.ext !== charAtIndex) {\n              return !1;\n            }\n          } else {\n            if (phoneNumber.ext) {\n              return !1;\n            }\n          }\n        }\n      }\n    }\n    return !0;\n  }\n  function isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {\n    if (\"FROM_DEFAULT_COUNTRY\" !== phoneNumber.__countryCallingCodeSource) {\n      return !0;\n    }\n    _ref5 = new _metadata2[\"default\"](_ref5.metadata);\n    _ref5.selectNumberingPlan(phoneNumber.countryCallingCode);\n    phoneNumber.country || (0,_getCountryByCallingCode[\"default\"])(phoneNumber.countryCallingCode, {nationalNumber:phoneNumber.nationalNumber, metadata:_ref5});\n    var nationalNumber = phoneNumber.nationalNumber;\n    nationalNumber = (0,_format.chooseFormatForNumber)(_ref5.numberingPlan.formats(), nationalNumber);\n    return nationalNumber.nationalPrefixFormattingRule() ? _ref5.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat() || !nationalNumber.usesNationalPrefix() ? !0 : !!phoneNumber.nationalPrefix : !0;\n  }\n  function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {\n    var firstSlashInBodyIndex = candidate.indexOf(\"/\");\n    if (0 > firstSlashInBodyIndex) {\n      return !1;\n    }\n    var secondSlashInBodyIndex = candidate.indexOf(\"/\", firstSlashInBodyIndex + 1);\n    return 0 > secondSlashInBodyIndex ? !1 : \"FROM_NUMBER_WITH_PLUS_SIGN\" !== phoneNumber.__countryCallingCodeSource && \"FROM_NUMBER_WITHOUT_PLUS_SIGN\" !== phoneNumber.__countryCallingCodeSource || (0,_parseDigits[\"default\"])(candidate.substring(0, firstSlashInBodyIndex)) !== phoneNumber.countryCallingCode ? !0 : 0 <= candidate.slice(secondSlashInBodyIndex + 1).indexOf(\"/\");\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.containsMoreThanOneSlashInNationalNumber = containsMoreThanOneSlashInNationalNumber;\n  exports[\"default\"] = void 0;\n  var _parseDigits = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$parseDigits\")), _matchPhoneNumberStringAgainstPhoneNumber = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$findNumbers$matchPhoneNumberStringAgainstPhoneNumber\")), _metadata2 = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$metadata\")), _getCountryByCallingCode = _interopRequireDefault(require(\"module$node_modules$libphonenumber_js$build$helpers$getCountryByCallingCode\")), \n  _format = require(\"module$node_modules$libphonenumber_js$build$format\");\n  require(\"module$node_modules$libphonenumber_js$build$findNumbers$util\");\n  exports[\"default\"] = {POSSIBLE:function(phoneNumber, _ref) {\n    return !0;\n  }, VALID:function(phoneNumber, _ref2) {\n    var candidate = _ref2.candidate;\n    _ref2 = _ref2.metadata;\n    return phoneNumber.isValid() && containsOnlyValidXChars(phoneNumber, candidate, _ref2) ? !0 : !1;\n  }, STRICT_GROUPING:function(phoneNumber, _ref3) {\n    var candidate = _ref3.candidate, defaultCountry = _ref3.defaultCountry;\n    _ref3 = _ref3.metadata;\n    if (phoneNumber.isValid() && containsOnlyValidXChars(phoneNumber, candidate, _ref3) && !containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) && isNationalPrefixPresentIfRequired(phoneNumber, {defaultCountry, metadata:_ref3})) {\n      throw Error(\"This part of code hasn't been ported\");\n    }\n    return !1;\n  }, EXACT_GROUPING:function(phoneNumber, _ref4) {\n    var candidate = _ref4.candidate, defaultCountry = _ref4.defaultCountry;\n    _ref4 = _ref4.metadata;\n    if (phoneNumber.isValid() && containsOnlyValidXChars(phoneNumber, candidate, _ref4) && !containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) && isNationalPrefixPresentIfRequired(phoneNumber, {defaultCountry, metadata:_ref4})) {\n      throw Error(\"This part of code hasn't been ported\");\n    }\n    return !1;\n  }};\n};\n","~:source","shadow$provide[\"module$node_modules$libphonenumber_js$build$findNumbers$Leniency\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsMoreThanOneSlashInNationalNumber = containsMoreThanOneSlashInNationalNumber;\nexports[\"default\"] = void 0;\nvar _parseDigits = _interopRequireDefault(require(\"../helpers/parseDigits.js\"));\nvar _matchPhoneNumberStringAgainstPhoneNumber = _interopRequireDefault(require(\"./matchPhoneNumberStringAgainstPhoneNumber.js\"));\nvar _metadata2 = _interopRequireDefault(require(\"../metadata.js\"));\nvar _getCountryByCallingCode = _interopRequireDefault(require(\"../helpers/getCountryByCallingCode.js\"));\nvar _format = require(\"../format.js\");\nvar _util = require(\"./util.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\nvar _default = exports[\"default\"] = {\n  /**\r\n   * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n   */\n  POSSIBLE: function POSSIBLE(phoneNumber, _ref) {\n    var candidate = _ref.candidate,\n      metadata = _ref.metadata;\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"possible\" and \"valid\".\r\n   * Numbers written in national format must have their national-prefix\r\n   * present if it is usually written for a number of this type.\r\n   */\n  VALID: function VALID(phoneNumber, _ref2) {\n    var candidate = _ref2.candidate,\n      defaultCountry = _ref2.defaultCountry,\n      metadata = _ref2.metadata;\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {\n      return false;\n    }\n\n    // Skipped for simplicity.\n    // return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\n    return true;\n  },\n  /**\r\n   * Phone numbers accepted are \"valid\" and\r\n   * are grouped in a possible way for this locale. For example, a US number written as\r\n   * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n   * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol in the national significant number\r\n   * are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use,\r\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n   */\n  STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, _ref3) {\n    var candidate = _ref3.candidate,\n      defaultCountry = _ref3.defaultCountry,\n      metadata = _ref3.metadata,\n      regExpCache = _ref3.regExpCache;\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\n      defaultCountry: defaultCountry,\n      metadata: metadata\n    })) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\n  },\n  /**\r\n   * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n   * that we would have formatted it, or as a single block.\r\n   * For example, a US number written as \"650 2530000\" is not accepted\r\n   * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n   * libphonenumber-discuss@googlegroups.com.\r\n   */\n  EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, _ref4) {\n    var candidate = _ref4.candidate,\n      defaultCountry = _ref4.defaultCountry,\n      metadata = _ref4.metadata,\n      regExpCache = _ref4.regExpCache;\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\n      defaultCountry: defaultCountry,\n      metadata: metadata\n    })) {\n      return false;\n    }\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\n  }\n};\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata) {\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (var index = 0; index < candidate.length - 1; index++) {\n    var charAtIndex = candidate.charAt(index);\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\n      var charAtNextIndex = candidate.charAt(index + 1);\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++;\n        if ((0, _matchPhoneNumberStringAgainstPhoneNumber[\"default\"])(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH') {\n          return false;\n        }\n        // This is the extension sign case, in which the 'x' or 'X' should always precede the\n        // extension number.\n      } else {\n        var ext = (0, _parseDigits[\"default\"])(candidate.substring(index));\n        if (ext) {\n          if (phoneNumber.ext !== ext) {\n            return false;\n          }\n        } else {\n          if (phoneNumber.ext) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {\n  var defaultCountry = _ref5.defaultCountry,\n    _metadata = _ref5.metadata;\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY') {\n    return true;\n  }\n  var metadata = new _metadata2[\"default\"](_metadata);\n  metadata.selectNumberingPlan(phoneNumber.countryCallingCode);\n  var phoneNumberRegion = phoneNumber.country || (0, _getCountryByCallingCode[\"default\"])(phoneNumber.countryCallingCode, {\n    nationalNumber: phoneNumber.nationalNumber,\n    metadata: metadata\n  });\n\n  // Check if a national prefix should be present when formatting this number.\n  var nationalNumber = phoneNumber.nationalNumber;\n  var format = (0, _format.chooseFormatForNumber)(metadata.numberingPlan.formats(), nationalNumber);\n\n  // To do this, we check that a national prefix formatting rule was present\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\n  if (format.nationalPrefixFormattingRule()) {\n    if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n      // The national-prefix is optional in these cases, so we don't need to check if it was present.\n      return true;\n    }\n    if (!format.usesNationalPrefix()) {\n      // National Prefix not needed for this number.\n      return true;\n    }\n    return Boolean(phoneNumber.nationalPrefix);\n  }\n  return true;\n}\nfunction containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {\n  var firstSlashInBodyIndex = candidate.indexOf('/');\n  if (firstSlashInBodyIndex < 0) {\n    // No slashes, this is okay.\n    return false;\n  }\n\n  // Now look for a second one.\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\n  if (secondSlashInBodyIndex < 0) {\n    // Only one slash, this is okay.\n    return false;\n  }\n\n  // If the first slash is after the country calling code, this is permitted.\n  var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' || phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN';\n  if (candidateHasCountryCode && (0, _parseDigits[\"default\"])(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\n  }\n  return true;\n}\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */);\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n    return true;\n  }\n\n  // If this didn't pass, see if there are any alternate formats that match, and try them instead.\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n  if (alternateFormats) {\n    for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done;) {\n      var alternateFormat = _step.value;\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\n        // There is only one leading digits pattern for alternate formats.\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\n          // Leading digits don't match; try another one.\n          continue;\n        }\n      }\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\n  throw new Error('This part of code hasn\\'t been ported');\n  if (formattingPattern) {\n    // We format the NSN only, and split that according to the separator.\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\n  }\n\n  // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata);\n\n  // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n  var endIndex = rfc3966Format.indexOf(';');\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length;\n  }\n\n  // The country-code will have a '-' following it.\n  var startIndex = rfc3966Format.indexOf('-') + 1;\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\n}\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN);\n\n  // Set this to the last group, skipping it if the number has an extension.\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1;\n\n  // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\n    return true;\n  }\n\n  // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\n      return false;\n    }\n    formattedNumberGroupIndex--;\n    candidateNumberGroupIndex--;\n  }\n\n  // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n  return candidateNumberGroupIndex >= 0 && (0, _util.endsWith)(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\n}\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var fromIndex = 0;\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\n    // First skip the country code if the normalized candidate contained it.\n    var countryCode = String(number.getCountryCode());\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\n  }\n\n  // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\n    if (fromIndex < 0) {\n      return false;\n    }\n    // Moves {@code fromIndex} forward.\n    fromIndex += formattedNumberGroups[i].length();\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n        return (0, _util.startsWith)(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\n      }\n    }\n  }\n\n  // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\n}\n//# sourceMappingURL=Leniency.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$libphonenumber_js$build$findNumbers$util","~$module$node_modules$libphonenumber_js$build$helpers$parseDigits","~$module$node_modules$libphonenumber_js$build$metadata","~$shadow.js","~$module$node_modules$libphonenumber_js$build$format","~$module$node_modules$libphonenumber_js$build$findNumbers$matchPhoneNumberStringAgainstPhoneNumber","~$module$node_modules$libphonenumber_js$build$helpers$getCountryByCallingCode"]],"~:properties",["^5",["STRICT_GROUPING","nationalNumber","POSSIBLE","__esModule","containsMoreThanOneSlashInNationalNumber","defaultCountry","value","metadata","EXACT_GROUPING","VALID"]],"~:compiled-at",1760720685917,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$libphonenumber_js$build$findNumbers$Leniency.js\",\n\"lineCount\":75,\n\"mappings\":\"AAAAA,cAAA,CAAA,gEAAA,GAAqF,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAc7HC,UAASA,uBAAsB,CAACC,CAAD,CAAI;AAAE,WAAOA,CAAA,IAAKA,CAAEC,CAAAA,UAAP,GAAoBD,CAApB,GAAwB,CAAE,UAAWA,CAAb,CAA/B;AAAF;AAoFnCE,UAASA,wBAAuB,CAACC,WAAD,EAAcC,SAAd,EAAyBC,QAAzB,CAAmC;AAMjE,SAAK,IAAIC,QAAQ,CAAjB,EAAoBA,KAApB,GAA4BF,SAAUG,CAAAA,MAAtC,GAA+C,CAA/C,EAAkDD,KAAA,EAAlD,CAA2D;AACzD,UAAIE,cAAcJ,SAAUK,CAAAA,MAAV,CAAiBH,KAAjB,CAAlB;AACA,UAAoB,GAApB,KAAIE,WAAJ,IAA2C,GAA3C,KAA2BA,WAA3B;AAEE,YADIE,WACA,GADkBN,SAAUK,CAAAA,MAAV,CAAiBH,KAAjB,GAAyB,CAAzB,CAClB,EAAoB,GAApB,KAAAI,WAAA,IAA+C,GAA/C,KAA2BA,WAA/B;AAIE,cADAJ,KAAA,EACI,EAAiH,WAAjH,KAAA,GAAIK,yCAAA,CAA0C,SAA1C,CAAJ,EAA0DP,SAAUQ,CAAAA,SAAV,CAAoBN,KAApB,CAA1D,EAAsFH,WAAtF,EAAmGE,QAAnG,CAAJ;AACE,mBAAO,CAAA,CAAP;AADF;AAJF;AAWE,cADIQ,WACJ,GADU,GAAIC,YAAA,CAAa,SAAb,CAAJ,EAA6BV,SAAUQ,CAAAA,SAAV,CAAoBN,KAApB,CAA7B,CACV;AACE,gBAAIH,WAAYU,CAAAA,GAAhB,KAAwBA,WAAxB;AACE,qBAAO,CAAA,CAAP;AADF;AADF;AAKE,gBAAIV,WAAYU,CAAAA,GAAhB;AACE,qBAAO,CAAA,CAAP;AADF;AALF;AAXF;AAFF;AAFyD;AA2B3D,WAAO,CAAA,CAAP;AAjCiE;AAmCnEE,UAASA,kCAAiC,CAACZ,WAAD,EAAca,KAAd,CAAqB;AAK7D,QAA+C,sBAA/C,KAAIb,WAAYc,CAAAA,0BAAhB;AACE,aAAO,CAAA,CAAP;AADF;AAGIZ,SAAAA,GAAW,IAAIa,UAAA,CAAW,SAAX,CAAJ,CANDF,KAAMX,CAAAA,QAML,CAAXA;AACJA,SAASc,CAAAA,mBAAT,CAA6BhB,WAAYiB,CAAAA,kBAAzC,CAAA;AACwBjB,eAAYkB,CAAAA,OAAZ,IAAuB,GAAIC,wBAAA,CAAyB,SAAzB,CAAJ,EAAyCnB,WAAYiB,CAAAA,kBAArD,EAAyE,CACtHG,eAAgBpB,WAAYoB,CAAAA,cAD0F,EAEtHlB,SAAUA,KAF4G,CAAzE,CAAvB;AAMxB,QAAIkB,iBAAiBpB,WAAYoB,CAAAA,cAAjC;AACIC,kBAAAA,GAAS,GAAIC,OAAQC,CAAAA,qBAAZ,EAAmCrB,KAASsB,CAAAA,aAAcC,CAAAA,OAAvB,EAAnC,EAAqEL,cAArE,CAATC;AAIJ,WAAIA,cAAOK,CAAAA,4BAAP,EAAJ,GACMxB,KAASsB,CAAAA,aAAcG,CAAAA,sDAAvB,EAIJ,IAAI,CAACN,cAAOO,CAAAA,kBAAP,EAAL,GAES,CAAA,CAFT,GAIO,CAAA,CAAQ5B,WAAY6B,CAAAA,cAT7B,GAWO,CAAA,CAXP;AArB6D;AAkC/DC,UAASA,yCAAwC,CAAC9B,WAAD,EAAcC,SAAd,CAAyB;AACxE,QAAI8B,wBAAwB9B,SAAU+B,CAAAA,OAAV,CAAkB,GAAlB,CAA5B;AACA,QAA4B,CAA5B,GAAID,qBAAJ;AAEE,aAAO,CAAA,CAAP;AAFF;AAMA,QAAIE,yBAAyBhC,SAAU+B,CAAAA,OAAV,CAAkB,GAAlB,EAAuBD,qBAAvB,GAA+C,CAA/C,CAA7B;AACA,WAA6B,CAA7B,GAAIE,sBAAJ,GAES,CAAA,CAFT,GAMyE,4BACzE,KAD8BjC,WAAYc,CAAAA,0BAC1C,IADoJ,+BACpJ,KADyGd,WAAYc,CAAAA,0BACrH,IAA+B,GAAIH,YAAA,CAAa,SAAb,CAAJ,EAA6BV,SAAUQ,CAAAA,SAAV,CAAoB,CAApB,EAAuBsB,qBAAvB,CAA7B,CAA/B,KAA+G/B,WAAYiB,CAAAA,kBAA3H,GAIO,CAAA,CAJP,GAEqE,CAFrE,IAEShB,SAAUiC,CAAAA,KAAV,CAAgBD,sBAAhB,GAAyC,CAAzC,CAA4CD,CAAAA,OAA5C,CAAoD,GAApD,CATT;AATwE;AApK1EG,QAAOC,CAAAA,cAAP,CAAsBzC,OAAtB,EAA+B,YAA/B,EAA6C,CAC3C0C,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGA1C,SAAQmC,CAAAA,wCAAR,GAAmDA,wCAAnD;AACAnC,SAAA,CAAQ,SAAR,CAAA,GAAqB,IAAK,EAA1B;AACA,MAAIgB,eAAef,sBAAA,CAAuBH,OAAA,CAAQ,iEAAR,CAAvB,CAAnB,EACIe,4CAA4CZ,sBAAA,CAAuBH,OAAA,CAAQ,kGAAR,CAAvB,CADhD,EAEIsB,aAAanB,sBAAA,CAAuBH,OAAA,CAAQ,sDAAR,CAAvB,CAFjB,EAGI0B,2BAA2BvB,sBAAA,CAAuBH,OAAA,CAAQ,6EAAR,CAAvB,CAH/B;AAII6B,YAAU7B,OAAA,CAAQ,oDAAR,CAJd;AAKYA,SAAA,CAAQ,8DAAR,CAAA;AASGE,SAAA,CAAQ,SAAR,CAAA,GAAqB,CAIlC2C,SAAUA,QAAiB,CAACtC,WAAD,EAAcuC,IAAd,CAAoB;AAG7C,WAAO,CAAA,CAAP;AAH6C,GAJb,EAclCC,MAAOA,QAAc,CAACxC,WAAD,EAAcyC,KAAd,CAAqB;AAAA,QACpCxC,YAAYwC,KAAMxC,CAAAA,SADkB;AAGtCC,SAAAA,GAAWuC,KAAMvC,CAAAA,QAAjBA;AACF,WAAKF,WAAY0C,CAAAA,OAAZ,EAAL,IAA+B3C,uBAAA,CAAwBC,WAAxB,EAAqCC,SAArC,EAAgDC,KAAhD,CAA/B,GAMO,CAAA,CANP,GACS,CAAA,CADT;AAJwC,GAdR,EAsClCyC,gBAAiBA,QAAwB,CAAC3C,WAAD,EAAc4C,KAAd,CAAqB;AAAA,QACxD3C,YAAY2C,KAAM3C,CAAAA,SADsC,EAE1D4C,iBAAiBD,KAAMC,CAAAA,cAFmC;AAG1D3C,SAAAA,GAAW0C,KAAM1C,CAAAA,QAAjBA;AAEF,QAAKF,WAAY0C,CAAAA,OAAZ,EAAL,IAA+B3C,uBAAA,CAAwBC,WAAxB,EAAqCC,SAArC,EAAgDC,KAAhD,CAA/B,IAA4F,CAAA4B,wCAAA,CAAyC9B,WAAzC,EAAsDC,SAAtD,CAA5F,IAAiKW,iCAAA,CAAkCZ,WAAlC,EAA+C,CAC9L6C,cAD8L,EAE9M3C,SAAUA,KAFoM,CAA/C,CAAjK;AA6HF,YAAU4C,KAAJ,CAAU,sCAAV,CAAN;AA7HE;AAAA,WAIS,CAAA,CAJT;AAL4D,GAtC5B,EA8DlCC,eAAgBA,QAAuB,CAAC/C,WAAD,EAAcgD,KAAd,CAAqB;AAAA,QACtD/C,YAAY+C,KAAM/C,CAAAA,SADoC,EAExD4C,iBAAiBG,KAAMH,CAAAA,cAFiC;AAGxD3C,SAAAA,GAAW8C,KAAM9C,CAAAA,QAAjBA;AAEF,QAAKF,WAAY0C,CAAAA,OAAZ,EAAL,IAA+B3C,uBAAA,CAAwBC,WAAxB,EAAqCC,SAArC,EAAgDC,KAAhD,CAA/B,IAA4F,CAAA4B,wCAAA,CAAyC9B,WAAzC,EAAsDC,SAAtD,CAA5F,IAAiKW,iCAAA,CAAkCZ,WAAlC,EAA+C,CAC9L6C,cAD8L,EAE9M3C,SAAUA,KAFoM,CAA/C,CAAjK;AAqGF,YAAU4C,KAAJ,CAAU,sCAAV,CAAN;AArGE;AAAA,WAIS,CAAA,CAJT;AAL0D,GA9D1B,CAArB;AAtB8G,CAA7H;;\",\n\"sources\":[\"node_modules/libphonenumber-js/build/findNumbers/Leniency.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$libphonenumber_js$build$findNumbers$Leniency\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.containsMoreThanOneSlashInNationalNumber = containsMoreThanOneSlashInNationalNumber;\\nexports[\\\"default\\\"] = void 0;\\nvar _parseDigits = _interopRequireDefault(require(\\\"../helpers/parseDigits.js\\\"));\\nvar _matchPhoneNumberStringAgainstPhoneNumber = _interopRequireDefault(require(\\\"./matchPhoneNumberStringAgainstPhoneNumber.js\\\"));\\nvar _metadata2 = _interopRequireDefault(require(\\\"../metadata.js\\\"));\\nvar _getCountryByCallingCode = _interopRequireDefault(require(\\\"../helpers/getCountryByCallingCode.js\\\"));\\nvar _format = require(\\\"../format.js\\\");\\nvar _util = require(\\\"./util.js\\\");\\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \\\"default\\\": e }; }\\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \\\"undefined\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\"@@iterator\\\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \\\"number\\\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\\\"string\\\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \\\"Object\\\" === t && r.constructor && (t = r.constructor.name), \\\"Map\\\" === t || \\\"Set\\\" === t ? Array.from(r) : \\\"Arguments\\\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\\n/**\\r\\n * Leniency when finding potential phone numbers in text segments\\r\\n * The levels here are ordered in increasing strictness.\\r\\n */\\nvar _default = exports[\\\"default\\\"] = {\\n  /**\\r\\n   * Phone numbers accepted are \\\"possible\\\", but not necessarily \\\"valid\\\".\\r\\n   */\\n  POSSIBLE: function POSSIBLE(phoneNumber, _ref) {\\n    var candidate = _ref.candidate,\\n      metadata = _ref.metadata;\\n    return true;\\n  },\\n  /**\\r\\n   * Phone numbers accepted are \\\"possible\\\" and \\\"valid\\\".\\r\\n   * Numbers written in national format must have their national-prefix\\r\\n   * present if it is usually written for a number of this type.\\r\\n   */\\n  VALID: function VALID(phoneNumber, _ref2) {\\n    var candidate = _ref2.candidate,\\n      defaultCountry = _ref2.defaultCountry,\\n      metadata = _ref2.metadata;\\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {\\n      return false;\\n    }\\n\\n    // Skipped for simplicity.\\n    // return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\\n    return true;\\n  },\\n  /**\\r\\n   * Phone numbers accepted are \\\"valid\\\" and\\r\\n   * are grouped in a possible way for this locale. For example, a US number written as\\r\\n   * \\\"65 02 53 00 00\\\" and \\\"650253 0000\\\" are not accepted at this leniency level, whereas\\r\\n   * \\\"650 253 0000\\\", \\\"650 2530000\\\" or \\\"6502530000\\\" are.\\r\\n   * Numbers with more than one '/' symbol in the national significant number\\r\\n   * are also dropped at this level.\\r\\n   *\\r\\n   * Warning: This level might result in lower coverage especially for regions outside of\\r\\n   * country code \\\"+1\\\". If you are not sure about which level to use,\\r\\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\\r\\n   */\\n  STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, _ref3) {\\n    var candidate = _ref3.candidate,\\n      defaultCountry = _ref3.defaultCountry,\\n      metadata = _ref3.metadata,\\n      regExpCache = _ref3.regExpCache;\\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\\n      defaultCountry: defaultCountry,\\n      metadata: metadata\\n    })) {\\n      return false;\\n    }\\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\\n  },\\n  /**\\r\\n   * Phone numbers accepted are \\\"valid\\\" and are grouped in the same way\\r\\n   * that we would have formatted it, or as a single block.\\r\\n   * For example, a US number written as \\\"650 2530000\\\" is not accepted\\r\\n   * at this leniency level, whereas \\\"650 253 0000\\\" or \\\"6502530000\\\" are.\\r\\n   * Numbers with more than one '/' symbol are also dropped at this level.\\r\\n   *\\r\\n   * Warning: This level might result in lower coverage especially for regions outside of\\r\\n   * country code \\\"+1\\\". If you are not sure about which level to use, email the discussion group\\r\\n   * libphonenumber-discuss@googlegroups.com.\\r\\n   */\\n  EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, _ref4) {\\n    var candidate = _ref4.candidate,\\n      defaultCountry = _ref4.defaultCountry,\\n      metadata = _ref4.metadata,\\n      regExpCache = _ref4.regExpCache;\\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\\n      defaultCountry: defaultCountry,\\n      metadata: metadata\\n    })) {\\n      return false;\\n    }\\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\\n  }\\n};\\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata) {\\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\\n  // national significant number or (2) an extension sign, in which case they always precede the\\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\\n  // or 'X'. We ignore the character if it appears as the last character of the string.\\n  for (var index = 0; index < candidate.length - 1; index++) {\\n    var charAtIndex = candidate.charAt(index);\\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\\n      var charAtNextIndex = candidate.charAt(index + 1);\\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\\n        // This is the carrier code case, in which the 'X's always precede the national\\n        // significant number.\\n        index++;\\n        if ((0, _matchPhoneNumberStringAgainstPhoneNumber[\\\"default\\\"])(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH') {\\n          return false;\\n        }\\n        // This is the extension sign case, in which the 'x' or 'X' should always precede the\\n        // extension number.\\n      } else {\\n        var ext = (0, _parseDigits[\\\"default\\\"])(candidate.substring(index));\\n        if (ext) {\\n          if (phoneNumber.ext !== ext) {\\n            return false;\\n          }\\n        } else {\\n          if (phoneNumber.ext) {\\n            return false;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return true;\\n}\\nfunction isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {\\n  var defaultCountry = _ref5.defaultCountry,\\n    _metadata = _ref5.metadata;\\n  // First, check how we deduced the country code. If it was written in international format, then\\n  // the national prefix is not required.\\n  if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY') {\\n    return true;\\n  }\\n  var metadata = new _metadata2[\\\"default\\\"](_metadata);\\n  metadata.selectNumberingPlan(phoneNumber.countryCallingCode);\\n  var phoneNumberRegion = phoneNumber.country || (0, _getCountryByCallingCode[\\\"default\\\"])(phoneNumber.countryCallingCode, {\\n    nationalNumber: phoneNumber.nationalNumber,\\n    metadata: metadata\\n  });\\n\\n  // Check if a national prefix should be present when formatting this number.\\n  var nationalNumber = phoneNumber.nationalNumber;\\n  var format = (0, _format.chooseFormatForNumber)(metadata.numberingPlan.formats(), nationalNumber);\\n\\n  // To do this, we check that a national prefix formatting rule was present\\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\\n  if (format.nationalPrefixFormattingRule()) {\\n    if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\\n      // The national-prefix is optional in these cases, so we don't need to check if it was present.\\n      return true;\\n    }\\n    if (!format.usesNationalPrefix()) {\\n      // National Prefix not needed for this number.\\n      return true;\\n    }\\n    return Boolean(phoneNumber.nationalPrefix);\\n  }\\n  return true;\\n}\\nfunction containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {\\n  var firstSlashInBodyIndex = candidate.indexOf('/');\\n  if (firstSlashInBodyIndex < 0) {\\n    // No slashes, this is okay.\\n    return false;\\n  }\\n\\n  // Now look for a second one.\\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\\n  if (secondSlashInBodyIndex < 0) {\\n    // Only one slash, this is okay.\\n    return false;\\n  }\\n\\n  // If the first slash is after the country calling code, this is permitted.\\n  var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' || phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN';\\n  if (candidateHasCountryCode && (0, _parseDigits[\\\"default\\\"])(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {\\n    // Any more slashes and this is illegal.\\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\\n  }\\n  return true;\\n}\\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\\n  throw new Error('This part of code hasn\\\\'t been ported');\\n  var normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */);\\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\\n    return true;\\n  }\\n\\n  // If this didn't pass, see if there are any alternate formats that match, and try them instead.\\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\\n  if (alternateFormats) {\\n    for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done;) {\\n      var alternateFormat = _step.value;\\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\\n        // There is only one leading digits pattern for alternate formats.\\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\\n          // Leading digits don't match; try another one.\\n          continue;\\n        }\\n      }\\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\r\\n * Helper method to get the national-number part of a number, formatted without any national\\r\\n * prefix, and return it as a set of digit blocks that would be formatted together following\\r\\n * standard formatting rules.\\r\\n */\\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\\n  throw new Error('This part of code hasn\\\\'t been ported');\\n  if (formattingPattern) {\\n    // We format the NSN only, and split that according to the separator.\\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\\n  }\\n\\n  // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata);\\n\\n  // We remove the extension part from the formatted string before splitting it into different\\n  // groups.\\n  var endIndex = rfc3966Format.indexOf(';');\\n  if (endIndex < 0) {\\n    endIndex = rfc3966Format.length;\\n  }\\n\\n  // The country-code will have a '-' following it.\\n  var startIndex = rfc3966Format.indexOf('-') + 1;\\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\\n}\\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\\n  throw new Error('This part of code hasn\\\\'t been ported');\\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN);\\n\\n  // Set this to the last group, skipping it if the number has an extension.\\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1;\\n\\n  // First we check if the national significant number is formatted as a block.\\n  // We use contains and not equals, since the national significant number may be present with\\n  // a prefix such as a national number prefix, or the country code itself.\\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\\n    return true;\\n  }\\n\\n  // Starting from the end, go through in reverse, excluding the first group, and check the\\n  // candidate and number groups are the same.\\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\\n      return false;\\n    }\\n    formattedNumberGroupIndex--;\\n    candidateNumberGroupIndex--;\\n  }\\n\\n  // Now check the first group. There may be a national prefix at the start, so we only check\\n  // that the candidate group ends with the formatted number group.\\n  return candidateNumberGroupIndex >= 0 && (0, _util.endsWith)(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\\n}\\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\\n  throw new Error('This part of code hasn\\\\'t been ported');\\n  var fromIndex = 0;\\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\\n    // First skip the country code if the normalized candidate contained it.\\n    var countryCode = String(number.getCountryCode());\\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\\n  }\\n\\n  // Check each group of consecutive digits are not broken into separate groupings in the\\n  // {@code normalizedCandidate} string.\\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\\n    if (fromIndex < 0) {\\n      return false;\\n    }\\n    // Moves {@code fromIndex} forward.\\n    fromIndex += formattedNumberGroups[i].length();\\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\\n      // We are at the position right after the NDC. We get the region used for formatting\\n      // information based on the country code in the phone number, rather than the number itself,\\n      // as we do not need to distinguish between different countries with the same country\\n      // calling code and this is faster.\\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\\n        // This means there is no formatting symbol after the NDC. In this case, we only\\n        // accept the number if there is no formatting symbol at all in the number, except\\n        // for extensions. This is only important for countries with national prefixes.\\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\\n        return (0, _util.startsWith)(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\\n      }\\n    }\\n  }\\n\\n  // The check here makes sure that we haven't mistakenly already used the extension to\\n  // match the last group of the subscriber number. Note the extension cannot have\\n  // formatting in-between digits.\\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\\n}\\n//# sourceMappingURL=Leniency.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"e\",\"__esModule\",\"containsOnlyValidXChars\",\"phoneNumber\",\"candidate\",\"metadata\",\"index\",\"length\",\"charAtIndex\",\"charAt\",\"charAtNextIndex\",\"_matchPhoneNumberStringAgainstPhoneNumber\",\"substring\",\"ext\",\"_parseDigits\",\"isNationalPrefixPresentIfRequired\",\"_ref5\",\"__countryCallingCodeSource\",\"_metadata2\",\"selectNumberingPlan\",\"countryCallingCode\",\"country\",\"_getCountryByCallingCode\",\"nationalNumber\",\"format\",\"_format\",\"chooseFormatForNumber\",\"numberingPlan\",\"formats\",\"nationalPrefixFormattingRule\",\"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\"usesNationalPrefix\",\"nationalPrefix\",\"containsMoreThanOneSlashInNationalNumber\",\"firstSlashInBodyIndex\",\"indexOf\",\"secondSlashInBodyIndex\",\"slice\",\"Object\",\"defineProperty\",\"value\",\"POSSIBLE\",\"_ref\",\"VALID\",\"_ref2\",\"isValid\",\"STRICT_GROUPING\",\"_ref3\",\"defaultCountry\",\"Error\",\"EXACT_GROUPING\",\"_ref4\"]\n}\n"]